#+AUTHOR: Denis Davidoglu
#+OPTIONS: H:3

* Table of contents
** Chapter 1 Computer Networks and the Internet
	- 1.1 What Is the Internet?
	- 1.2 The Network Edge
	- 1.3 The Network Core
	- 1.4 Delay, Loss, and Throughput in Packet-Switched Networks
	- 1.5 Protocol Layers and Their Service Models
	- 1.6 Networks Under Attack
	- 1.7 History of Computer Networking and the Internet
** Chapter 2 Application Layer
	- 2.1 Principles of Network Applications
	- 2.2 The Web and HTTP
	- 2.3 Electronic Mail in the Internet
	- 2.4 DNS—The Internet’s Directory Service
	- 2.5 Peer-to-Peer File Distribution
	- 2.6 Video Streaming and Content Distribution Networks
	- 2.7 Socket Programming: Creating Network Applications
** Chapter 3 Transport Layer
	- 3.1 Introduction and Transport-Layer Services
	- 3.2 Multiplexing and Demultiplexing
	- 3.3 Connectionless Transport: UDP
	- 3.4 Principles of Reliable Data Transfer
	- 3.5 Connection-Oriented Transport: TCP
	- 3.6 Principles of Congestion Control
	- 3.7 TCP Congestion Control

* Computer Networking. A Top Down Approach, 7th
  :PROPERTIES:
  :NOTER_DOCUMENT: docs/Computer Networking. A Top Down Approach, 7th.pdf
  :END:
** Chapter 1 Computer Networks and the Internet
   :PROPERTIES:
   :NOTER_PAGE: 26
   :END:
*** 1.1 What Is the Internet?
    :PROPERTIES:
    :NOTER_PAGE: 28
    :END:
**** What are nontraditional devices being connected to the Internet referred to as in Internet jargon?
     :PROPERTIES:
     :NOTER_PAGE: 28
     :HIGHLIGHT: #s(pdf-highlight 28 ((0.6085080147965475 0.5296867695184666 0.7965474722564735 0.5722300140252454)))
     :END:
 #+BEGIN_QUOTE
 Internet. Indeed, the term computer
 network is beginning to sound a bit dated, given the many nontraditional devices that are being hooked
 up to the Internet. In Internet jargon, all of these devices are called hosts or end systems.
 #+END_QUOTE
**** How are end systems connected in a network of communication?
     :PROPERTIES:
     :NOTER_PAGE: 29
     :HIGHLIGHT: #s(pdf-highlight 29 ((0.0659679408138101 0.9093034128097243 0.8674475955610358 0.9149135109864424)))
     :END:
 #+BEGIN_QUOTE
 End systems are connected together by a network of communication links and packet switches.
 #+END_QUOTE
**** Notes for page 30
     :PROPERTIES:
     :NOTER_PAGE: 30
     :HIGHLIGHT: #s(pdf-highlight 30 ((0.07891491985203453 0.07152875175315568 0.17447595561035759 0.10846189808321646)))
     :END:
 #+BEGIN_QUOTE
 Different links can transmit data at different rates, with the transmission rate of a link measured in
 bits/second.
 #+END_QUOTE

 #+BEGIN_QUOTE
 The resulting packages of information,
 known as packets in the jargon of computer networks, are then sent through the network to the
 destination end system, where they are reassembled into the original data.
 #+END_QUOTE

 #+BEGIN_QUOTE
 A packet switch takes a packet arriving on one of its incoming communication links and forwards that
 packet on one of its outgoing communication links. Packet switches come in many shapes and flavors,
 but the two most prominent types in today’s Internet are routers and link-layer switches.
 #+END_QUOTE
**** End systems access the Internet through Internet Service Providers (ISPs),
     :PROPERTIES:
     :NOTER_PAGE: 30
     :HIGHLIGHT: #s(pdf-highlight 30 ((0.08446362515413071 0.6839644693782142 0.6781750924784217 0.6802244039270687)))
     :END:
**** Notes for page 31
     :PROPERTIES:
     :NOTER_PAGE: 31
     :HIGHLIGHT: #s(pdf-highlight 31 ((0.4599260172626387 0.14118747078073868 0.686189889025894 0.16549789621318373)))
     :END:
 #+BEGIN_QUOTE
 The Transmission Control Protocol (TCP) and the
 Internet Protocol (IP) are two of the most important protocols in the Internet.
 #+END_QUOTE

 #+BEGIN_QUOTE
 Internet ­standards are developed by the Internet Engineering Task Force
 (IETF) [IETF 2016]. The IETF standards documents are called requests for comments (RFCs)
 #+END_QUOTE
**** Notes for page 32
     :PROPERTIES:
     :NOTER_PAGE: 32
     :HIGHLIGHT: #s(pdf-highlight 32 ((0.08261405672009864 0.2267414679756896 0.7016029593094945 0.30014025245441794)))
     :END:
 #+BEGIN_QUOTE
 End systems attached to the Internet provide a socket interface that specifies how a program running
 on one end system asks the Internet infrastructure to deliver data to a specific destination program
 running on another end system. This Internet socket interface is a set of rules that the sending program
 must follow so that the Internet can deliver the data to the destination program.
 #+END_QUOTE
**** Use internet services and don't write everything from scratch
     :PROPERTIES:
     :NOTER_PAGE: 32
     :HIGHLIGHT: #s(pdf-highlight 32 ((0.07829839704069051 0.544179523141655 0.5147965474722564 0.6129032258064516)))
     :END:
 #+BEGIN_QUOTE
 The postal service, of course, provides more than one service to its customers. It provides express
 delivery, reception confirmation, ordinary use, and many more services. In a similar manner, the Internet
 provides multiple services to its applications. When you develop an Internet application, you too must
 choose one of the Internet’s services for your application.
 #+END_QUOTE
**** Definition of protocol
     :PROPERTIES:
     :NOTER_PAGE: 35
     :HIGHLIGHT: #s(pdf-highlight 35 ((0.11220715166461159 0.1187470780738663 0.218249075215783 0.16035530621785882)))
     :END:
 #+BEGIN_QUOTE
 A protocol defines the format and the order of messages exchanged between two or more
 communicating entities, as well as the actions taken on the transmission and/or receipt of a message
 or other event.
 #+END_QUOTE
*** 1.2 The Network Edge
    :PROPERTIES:
    :NOTER_PAGE: 36
    :END:
**** End systems, because they sit at the edge of the internet. Also reffered to as hosts, because they run the application
     :PROPERTIES:
     :NOTER_PAGE: 36
     :HIGHLIGHT: #s(pdf-highlight 36 ((0.6307028360049322 0.3394109396914446 0.5684340320591862 0.3599812996727443)))
     :END:
 #+BEGIN_QUOTE
 the computers and other devices
 connected to the Internet are often referred to as end systems.
 #+END_QUOTE
**** Access network
     :PROPERTIES:
     :NOTER_PAGE: 38
     :HIGHLIGHT: #s(pdf-highlight 38 ((0.08754623921085081 0.8803179055633474 0.7108508014796547 0.916783543712015)))
     :END:
 #+BEGIN_QUOTE
 access network—the network that physically connects an end system to the first router (also known as
 the “edge router”) on a path from the end system to any other distant end system.
 #+END_QUOTE
**** Stationary phones. Data is analog and decoded into digital at the office's DSLAM
     :PROPERTIES:
     :NOTER_PAGE: 40
     :HIGHLIGHT: #s(pdf-highlight 40 ((0.08261405672009864 0.18513323983169708 0.4716399506781751 0.23796166432912577)))
     :END:
 #+BEGIN_QUOTE
 Today, the two most prevalent types of broadband residential access are digital subscriber line (DSL)
 and cable. A residence typically obtains DSL Internet access from the same local telephone company
 (telco) that provides its wired local phone access.
 #+END_QUOTE
**** Internet through coaxial television cable
     :PROPERTIES:
     :NOTER_PAGE: 41
     :HIGHLIGHT: #s(pdf-highlight 41 ((0.08199753390875462 0.38709677419354843 0.5357583230579531 0.5212716222533894)))
     :END:
 #+BEGIN_QUOTE
 While DSL makes use of the telco’s existing local telephone infrastructure, cable Internet access
 makes use of the cable television company’s existing cable television infrastructure. A residence obtains
 cable Internet access from the same company that provides its cable television. As illustrated in Figure
 1.6, fiber optics connect the cable head end to neighborhood-level junctions, from which traditional
 coaxial cable is then used to reach individual houses and apartments. Each neighborhood junction
 typically supports 500 to 5,000 homes. Because both fiber and coaxial cable are employed in this
 system, it is often referred to as hybrid fiber coax (HFC).
 #+END_QUOTE
**** Figure 1.6 A hybrid fiber-coaxial access network
	 :PROPERTIES:
	 :NOTER_PAGE: 41
	 :HIGHLIGHT: #s(pdf-highlight 41 ((0.0745466756212223 0.8737270875763746 0.5480188045668234 0.8783095723014256)))
	 :END:
#+DOWNLOADED: screenshot @ 2023-10-28 11:23:35
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_11-23-35_screenshot.png]]

**** Why DSL networks are asymmetric
     :PROPERTIES:
     :NOTER_PAGE: 42
     :HIGHLIGHT: #s(pdf-highlight 42 ((0.2644882860665845 0.1841982234689107 0.6134401972872996 0.23048153342683497)))
     :END:
 #+BEGIN_QUOTE
 The ­DOCSIS 2.0 standard defines downstream rates up to 42.8 Mbps and
 upstream rates of up to 30.7 Mbps. As in the case of DSL networks, the maximum achievable rate may
 not be realized due to lower contracted data rates or media impairments.
 #+END_QUOTE
**** Local area network (LAN)
     :PROPERTIES:
     :NOTER_PAGE: 43
     :HIGHLIGHT: #s(pdf-highlight 43 ((0.4919852034525278 0.8695652173913044 0.876078914919852 0.8962131837307153)))
     :END:
 #+BEGIN_QUOTE
 Although there are many types of LAN technologies,
 Ethernet is by far the most prevalent access technology in corporate, university, and home networks.
 #+END_QUOTE
**** Speed of Ethernet
     :PROPERTIES:
     :NOTER_PAGE: 44
     :HIGHLIGHT: #s(pdf-highlight 44 ((0.6750924784217016 0.394109396914446 0.24784217016029594 0.44506778868630203)))
     :END:
 #+BEGIN_QUOTE
 With Ethernet access, users
 typically have 100 Mbps or 1 Gbps access to the Ethernet switch, whereas servers may have 1 Gbps or
 even 10 Gbps access.
 #+END_QUOTE
**** Cell network
     :PROPERTIES:
     :NOTER_PAGE: 45
     :HIGHLIGHT: #s(pdf-highlight 45 ((0.08076448828606658 0.4015895278167368 0.6208384710234279 0.493221131369799)))
     :END:
 #+BEGIN_QUOTE
 Increasingly, devices such as iPhones and Android devices are being used to message, share photos in
 social networks, watch movies, and stream music while on the run. These devices employ the same
 wireless infrastructure used for cellular telephony to send/receive packets through a base station that is
 operated by the cellular network provider. Unlike WiFi, a user need only be within a few tens of
 kilometers (as opposed to a few tens of meters) of the base station.
 #+END_QUOTE
**** Guided & unguided media
     :PROPERTIES:
     :NOTER_PAGE: 46
     :HIGHLIGHT: #s(pdf-highlight 46 ((0.17077681874229347 0.292192613370734 0.5591861898890259 0.36231884057971014)))
     :END:
 #+BEGIN_QUOTE
 Physical media fall into two categories: guided media and unguided media. With guided
 media, the waves are guided along a solid medium, such as a fiber-optic cable, a twisted-pair copper
 wire, or a coaxial cable. With unguided media, the waves propagate in the atmosphere and in outer
 space, such as in a wireless LAN or a digital satellite channel.
 #+END_QUOTE
**** twisted wire pairs
     :PROPERTIES:
     :NOTER_PAGE: 46
     :HIGHLIGHT: #s(pdf-highlight 46 ((0.3027127003699137 0.788218793828892 0.7755856966707768 0.8574100046750819)))
     :END:
 #+BEGIN_QUOTE
 A wire pair constitutes a single communication link. Unshielded twisted
 pair (UTP) is commonly used for computer networks within a building, that is, for LANs. Data rates for
 LANs using twisted pair today range from 10 Mbps to 10 Gbps. The data rates that can be achieved
 depend on the thickness of the wire and the distance between transmitter and receiver.
 #+END_QUOTE
**** Fiber Optics
     :PROPERTIES:
     :NOTER_PAGE: 47
     :HIGHLIGHT: #s(pdf-highlight 47 ((0.08323057953144267 0.5558672276764843 0.5776818742293465 0.6493688639551193)))
     :END:
 #+BEGIN_QUOTE
 An optical fiber is a thin, flexible medium that conducts pulses of light, with each pulse representing a
 bit. A single optical fiber can support tremendous bit rates, up to tens or even hundreds of gigabits per
 second. They are immune to electromagnetic interference, have very low signal attenuation up to 100
 kilometers, and are very hard to tap. These characteristics have made fiber optics the preferred long-
 haul guided transmission media, particularly for overseas links.
 #+END_QUOTE
*** 1.3 The Network Core
    :PROPERTIES:
    :NOTER_PAGE: 49
    :END:
**** Network core
     :PROPERTIES:
     :NOTER_PAGE: 49
     :HIGHLIGHT: #s(pdf-highlight 49 ((0.7108508014796547 0.18045815801776532 0.6652281134401973 0.20617110799438992)))
     :END:
 #+BEGIN_QUOTE
 network core—the mesh
 of packet switches and links that interconnects the Internet’s end systems.
 #+END_QUOTE
**** Transmission rate
     :PROPERTIES:
     :NOTER_PAGE: 50
     :HIGHLIGHT: #s(pdf-highlight 50 ((0.6855733662145499 0.3394109396914446 0.4525277435265105 0.41748480598410476)))
     :END:
 #+BEGIN_QUOTE
 Packets are transmitted over
 each communication link at a rate equal to the full transmission rate of the link. So, if a source end
 system or a packet switch is sending a packet of L bits over a link with transmission rate R bits/sec, then
 the time to transmit the packet is L / R seconds.
 #+END_QUOTE
**** Store and forward transmission
     :PROPERTIES:
     :NOTER_PAGE: 50
     :HIGHLIGHT: #s(pdf-highlight 50 ((0.08569667077681874 0.4988312295465171 0.46054254007398276 0.544179523141655)))
     :END:
 #+BEGIN_QUOTE
 Most packet switches use store-and-forward transmission at the inputs to the links. Store-and-forward
 transmission means that the packet switch must receive the entire packet before it can begin to transmit
 the first bit of the packet onto the outbound link.
 #+END_QUOTE
**** Formula for end-to-end transmission delay
     :PROPERTIES:
     :NOTER_PAGE: 51
     :HIGHLIGHT: #s(pdf-highlight 51 ((0.07953144266337854 0.5717625058438522 0.21763255240443896 0.6657316503038804)))
     :END:
 #+BEGIN_QUOTE
 Let’s now consider the general case of sending one packet from source to destination over a path
 consisting of N links each of rate R (thus, there are N-1 routers between source and destination).
 Applying the same logic as above, we see that the end-to-end delay is:
 dend-to-end=NLR
 #+END_QUOTE
**** How routers know where to forwards the packet
     :PROPERTIES:
     :NOTER_PAGE: 53
     :HIGHLIGHT: #s(pdf-highlight 53 ((0.2521578298397041 0.10799438990182329 0.24475955610357583 0.2356241234221599)))
     :END:
 #+BEGIN_QUOTE
 As with postal addresses, this address has a hierarchical structure. When a packet
 arrives at a router in the network, the router examines a portion of the packet’s destination address and
 forwards the packet to an adjacent router. More specifically, each router has a forwarding table that
 maps destination addresses (or portions of the destination addresses) to that router’s outbound links.
 When a packet arrives at a router, the router examines the address and searches its forwarding table,
 using this destination address, to find the appropriate outbound link. The router then directs the packet
 to this outbound link.
 #+END_QUOTE
**** Routing protocol
     :PROPERTIES:
     :NOTER_PAGE: 53
     :HIGHLIGHT: #s(pdf-highlight 53 ((0.38286066584463624 0.7611033193080879 0.2644882860665845 0.8382421692379617)))
     :END:
 #+BEGIN_QUOTE
 Internet has a number of special routing protocols that are used
 to automatically set the forwarding tables. A routing protocol may, for example, determine the shortest
 path from each router to each destination and use the shortest path results to configure the forwarding
 tables in the routers.
 #+END_QUOTE
**** Trace-route is for seeing how packets take end-to-end routes in the internet
     :PROPERTIES:
     :NOTER_PAGE: (53 0.860682561944834 . 0.05980271270036989)
     :END:
**** Circuit-switched networks
     :PROPERTIES:
     :NOTER_PAGE: 54
     :HIGHLIGHT: #s(pdf-highlight 54 ((0.08569667077681874 0.24029920523609163 0.41800246609124536 0.33099579242636745)))
     :END:
 #+BEGIN_QUOTE
 In circuit-switched networks, the resources needed along a path (buffers, link transmission rate) to
 provide for communication between the end systems are reserved for the duration of the communication
 session between the end systems. In packet-switched networks, these resources are not reserved; a
 session’s messages use the resources on demand and, as a consequence, may have to wait (that is,
 queue) for access to a communication link.
 #+END_QUOTE
**** Advantage of circuit-switch approach
     :PROPERTIES:
     :NOTER_PAGE: 54
     :HIGHLIGHT: #s(pdf-highlight 54 ((0.3316892725030826 0.646096306685367 0.8723797780517879 0.683496961196821)))
     :END:
 #+BEGIN_QUOTE
 Since a given transmission rate has been reserved for this sender-to-
 receiver connection, the sender can transfer the data to the receiver at the guaranteed constant rate.
 #+END_QUOTE
**** Circuit link is implemented by reserving a bandwidth
     :PROPERTIES:
     :NOTER_PAGE: 55
     :HIGHLIGHT: #s(pdf-highlight 55 ((0.08199753390875462 0.6171107994389902 0.6066584463625154 0.7503506311360449)))
     :END:
 #+BEGIN_QUOTE
 A circuit in a link is implemented with either frequency-division multiplexing (FDM) or time-division
 multiplexing (TDM). With FDM, the frequency spectrum of a link is divided up among the connections
 established across the link. Specifically, the link dedicates a frequency band to each connection for the
 duration of the connection. In telephone networks, this frequency band typically has a width of 4 kHz
 (that is, 4,000 hertz or 4,000 cycles per second). The width of the band is called, not surprisingly, the
 bandwidth. FM radio stations also use FDM to share the frequency spectrum between 88 MHz and 108
 MHz, with each station being allocated a specific frequency band.
 #+END_QUOTE
**** FDM
     :PROPERTIES:
     :NOTER_PAGE: 56
     :HIGHLIGHT: #s(pdf-highlight 56 ((0.8144266337854501 0.44647031323048153 0.07706535141800247 0.32071061243571763)))
     :END:
 #+BEGIN_QUOTE
 Figure 1.14 illustrates FDM and TDM for a specific network link supporting up to four circuits. For FDM,
 the frequency domain is segmented into four bands, each of bandwidth 4 kHz. For TDM, the time
 domain is segmented into frames, with four time slots in each frame; each circuit is assigned the same
 dedicated slot in the revolving TDM frames. For TDM, the transmission rate of a circuit is equal to the
 frame rate multiplied by the number of bits in a slot. For example, if the link transmits 8,000 frames per
 second and each slot consists of 8 bits, then the transmission rate of each circuit is 64 kbps.
 #+END_QUOTE
**** FDM vs TDM
     :PROPERTIES:
     :NOTER_PAGE: 56
     :HIGHLIGHT: #s(pdf-highlight 56 ((0.08138101109741061 0.22440392706872372 0.6750924784217016 0.2697522206638616)))
     :END:
 #+BEGIN_QUOTE
 Figure 1.14
 With FDM, each circuit continuously gets a fraction of the bandwidth. With TDM, each circuit gets all of
 the bandwidth periodically during brief intervals of time (that is, during slots)
 #+END_QUOTE

#+DOWNLOADED: screenshot @ 2023-10-28 11:46:10
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_11-46-10_screenshot.png]]

**** TDM calculation
     :PROPERTIES:
     :NOTER_PAGE: 56
     :HIGHLIGHT: #s(pdf-highlight 56 ((0.34525277435265106 0.7844787283777467 0.6676942046855734 0.9111734455352969)))
     :END:
 #+BEGIN_QUOTE
 Let us consider how long it takes to send a file of 640,000 bits from
 Host A to Host B over a circuit-switched network. Suppose that all links in the network use TDM with 24
 slots and have a bit rate of 1.536 Mbps. Also suppose that it takes 500 msec to establish an end-to-end
 circuit before Host A can begin to transmit the file. How long does it take to send the file? Each circuit
 has a transmission rate of (1.536 Mbps)/24=64 kbps, so it takes (640,000 bits)/(64 kbps)=10 seconds to
 transmit the file. To this 10 seconds we add the circuit establishment time, giving 10.5 seconds to send
 the file. Note that the transmission time is independent of the number of links:
 #+END_QUOTE
**** Superiority of packet switching over circuit switching
     :PROPERTIES:
     :NOTER_PAGE: 58
     :HIGHLIGHT: #s(pdf-highlight 58 ((0.5135635018495684 0.21131369798971483 0.1498150431565968 0.2926601215521272)))
     :END:
 #+BEGIN_QUOTE
 Circuit switching pre-allocates use of the
 transmission link regardless of demand, with allocated but unneeded link time going unused. Packet
 switching on the other hand allocates link use on demand. Link transmission capacity will be shared on
 a packet-by-packet basis only among those users who have packets that need to be transmitted over
 the link.
 #+END_QUOTE
**** multi-home, lower latency and protections against failures
     :PROPERTIES:
     :NOTER_PAGE: 60
     :HIGHLIGHT: #s(pdf-highlight 60 ((0.3279901356350185 0.23094904160822816 0.6078914919852034 0.3165030388031791)))
     :END:
 #+BEGIN_QUOTE
 Any ISP (except for tier-1 ISPs) may choose to multi-home, that is, to
 connect to two or more provider ISPs. So, for example, an access ISP may multi-home with two regional
 ISPs, or it may multi-home with two regional ISPs and also with a tier-1 ISP. Similarly, a regional ISP
 may multi-home with multiple tier-1 ISPs. When an ISP multi-homes, it can continue to send and receive
 packets into the Internet even if one of its providers has a failure.
 #+END_QUOTE
**** internet exchange points
     :PROPERTIES:
     :NOTER_PAGE: 60
     :HIGHLIGHT: #s(pdf-highlight 60 ((0.26078914919852036 0.5273492286115007 0.3557336621454994 0.5591397849462366)))
     :END:
 #+BEGIN_QUOTE
 Along these same lines, a third-party company can create an Internet Exchange
 Point (IXP), which is a meeting point where multiple ISPs can peer together. An IXP is typically in a
 stand-alone building with its own switches
 #+END_QUOTE
**** Content-provider networks, today's internet
     :PROPERTIES:
     :NOTER_PAGE: 60
     :HIGHLIGHT: #s(pdf-highlight 60 ((0.08138101109741061 0.6573165030388032 0.29469790382244143 0.7442730247779337)))
     :END:
 #+BEGIN_QUOTE
 We now finally arrive at Network Structure 5, which describes today’s Internet. Network Structure 5,
 illustrated in Figure 1.15, builds on top of Network Structure 4 by adding content-provider networks.
 Google is currently one of the leading examples of such a content-provider network. As of this writing, it
 is estimated that Google has 50–100 data centers distributed across North America, Europe, Asia,
 South America, and Australia.
 #+END_QUOTE
#+DOWNLOADED: screenshot @ 2023-10-28 11:47:03
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_11-47-03_screenshot.png]]

*** 1.4 Delay, Loss, and Throughput in Packet-Switched Networks
    :PROPERTIES:
    :NOTER_PAGE: 62
    :END:
**** Processing Delay
     :PROPERTIES:
     :NOTER_PAGE: 63
     :HIGHLIGHT: #s(pdf-highlight 63 ((0.07953144266337854 0.44880785413744745 0.1535141800246609 0.5717625058438522)))
     :END:
 #+BEGIN_QUOTE
 The time required to examine the packet’s header and determine where to direct the packet is part of
 the processing delay. The processing delay can also include other factors, such as the time needed to
 check for bit-level errors in the packet that occurred in transmitting the packet’s bits from the upstream
 node to router A. Processing delays in high-speed routers are typically on the order of microseconds or
 less. After this nodal processing, the router directs the packet to the queue that precedes the link to
 router B.
 #+END_QUOTE
**** Queueing Delay
     :PROPERTIES:
     :NOTER_PAGE: 63
     :HIGHLIGHT: #s(pdf-highlight 63 ((0.08199753390875462 0.6517064048620851 0.42293464858199753 0.8209443665264142)))
     :END:
 #+BEGIN_QUOTE
 At the queue, the packet experiences a queuing delay as it waits to be transmitted onto the link. The
 length of the queuing delay of a specific packet will depend on the number of earlier-arriving packets
 that are queued and waiting for transmission onto the link. If the queue is empty and no other packet is
 currently being transmitted, then our packet’s queuing delay will be zero. On the other hand, if the traffic
 is heavy and many other packets are also waiting to be transmitted, the queuing delay will be long. We
 will see shortly that the number of packets that an arriving packet might expect to find is a function of the
 intensity and nature of the traffic arriving at the queue. ­Queuing delays can be on the order of
 microseconds to milliseconds in practice.
 #+END_QUOTE
**** Transmission Delay
     :PROPERTIES:
     :NOTER_PAGE: 63
     :HIGHLIGHT: #s(pdf-highlight 63 ((0.07644882860665844 0.8957456755493222 0.8951911220715166 0.9401589527816737)))
     :END:
 #+BEGIN_QUOTE
 Assuming that packets are transmitted in a first-come-first-served manner, as is common in packet-
 switched networks, our packet can be transmitted only after all the packets that have arrived before it
 have been transmitted. Denote the length of the packet by L bits, and denote the transmission rate of
 the link from router A to router B by R bits/sec. For example, for a 10 Mbps Ethernet link, the rate is
 R=10 Mbps; for a 100 Mbps Ethernet link, the rate is R=100 Mbps. The transmission delay is L/R. This
 is the amount of time required to push (that is, transmit) all of the packet’s bits into the link.
 Transmission delays are typically on the order of microseconds to milliseconds in practice.
 #+END_QUOTE
**** Propagation Delay
     :PROPERTIES:
     :NOTER_PAGE: 64
     :HIGHLIGHT: #s(pdf-highlight 64 ((0.08199753390875462 0.201028517999065 0.7281134401972873 0.40766713417484807)))
     :END:
 #+BEGIN_QUOTE
 Once a bit is pushed into the link, it needs to propagate to router B. The time required to propagate from
 the beginning of the link to router B is the propagation delay. The bit propagates at the propagation
 speed of the link. The propagation speed depends on the physical medium of the link (that is, fiber
 optics, twisted-pair copper wire, and so on) and is in the range of
 2⋅108 meters/sec to 3⋅108 meters/sec
 which is equal to, or a little less than, the speed of light. The propagation delay is the distance between
 two routers divided by the propagation speed. That is, the propagation delay is d/s, where d is the
 distance between router A and router B and s is the propagation speed of the link.
 #+END_QUOTE
**** Difference between transmission and propagation
     :PROPERTIES:
     :NOTER_PAGE: 64
     :HIGHLIGHT: #s(pdf-highlight 64 ((0.5197287299630087 0.8798503973819543 0.8199753390875463 0.7615708274894811)))
     :END:
 #+BEGIN_QUOTE
 The
 transmission delay is the amount of time required for the router to push out the packet; it is a function of
 the packet’s length and the transmission rate of the link, but has nothing to do with the distance between
 the two routers. The propagation delay, on the other hand, is the time it takes a bit to propagate from
 one router to the next; it is a function of the distance between the two routers, but has nothing to do with
 the packet’s length or the transmission rate of the link.
 #+END_QUOTE
**** Queuing delay is not constant and is analyzed using probability theory
     :PROPERTIES:
     :NOTER_PAGE: 66
     :HIGHLIGHT: #s(pdf-highlight 66 ((0.19510703363914372 0.5672541743970315 0.8880733944954128 0.6808905380333952)))
     :END:
 #+BEGIN_QUOTE
 Unlike the other three delays (namely, dproc, dtrans, and dprop), the queuing delay can vary
 from packet to packet. For example, if 10 packets arrive at an empty queue at the same time, the first
 packet transmitted will suffer no queuing delay, while the last packet transmitted will suffer a relatively
 large queuing delay (while it waits for the other nine packets to be transmitted). Therefore, when
 characterizing queuing delay, one typically uses statistical measures, such as average queuing delay,
 variance of queuing delay, and the probability that the queuing delay exceeds some specified value.
 #+END_QUOTE
**** Traffic intensity
     :PROPERTIES:
     :NOTER_PAGE: 66
     :HIGHLIGHT: #s(pdf-highlight 66 ((0.38470948012232414 0.8849721706864564 0.8048929663608562 0.922077922077922)))
     :END:
 #+BEGIN_QUOTE
 The ratio La/R, called the traffic intensity, often plays an
 important role in estimating the extent of the queuing delay. If La/R > 1, then the average rate at which
 bits arrive at the queue exceeds the rate at which the bits can be transmitted from the queue.
 #+END_QUOTE
**** La/R formula
	 :PROPERTIES:
	 :NOTER_PAGE: 66
	 :HIGHLIGHT: #s(pdf-highlight 66 ((0.13333333333333333 0.7950819672131147 0.6186186186186186 0.8410746812386156)))
	 :END:
#+BEGIN_QUOTE
let a denote the average rate at which packets arrive at the queue (a is in units of packets/sec).
Recall that R is the transmission rate; that is, it is the rate (in bits/sec) at which bits are pushed out of the
queue. Also suppose, for simplicity, that all packets consist of L bits.
#+END_QUOTE
**** Design your system so that the traffic intensity is no greater than 1.
     :PROPERTIES:
     :NOTER_PAGE: 67
     :HIGHLIGHT: #s(pdf-highlight 67 ((0.601834862385321 0.07838589981447125 0.3009174311926605 0.11410018552875696)))
     :END:
**** Average queing delay grows exponentially compared to La/R
     :PROPERTIES:
     :NOTER_PAGE: 68
     :HIGHLIGHT: #s(pdf-highlight 68 ((0.6948012232415902 0.300556586270872 0.056880733944954125 0.3051948051948052)))
     :END:
 ``Figure 1.18 Dependence of average queuing delay on traffic intensity''
#+DOWNLOADED: screenshot @ 2023-10-28 11:56:20
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_11-56-20_screenshot.png]]
**** Packets are lost due to finite queues inside routers
     :PROPERTIES:
     :NOTER_PAGE: (68 0.5500927643784786 . 0.06330275229357796)
     :END:
**** Packetization delay
     :PROPERTIES:
     :NOTER_PAGE: 71
     :HIGHLIGHT: #s(pdf-highlight 71 ((0.3021406727828746 0.39192949907235625 0.6232415902140672 0.5273654916512059)))
     :END:
 #+BEGIN_QUOTE
 For example, an end system wanting to transmit a packet into a shared
 medium (e.g., as in a WiFi or cable modem scenario) may purposefully delay its transmission as part of
 its protocol for sharing the medium with other end systems; we’ll consider such protocols in detail in
 Chapter 6. Another important delay is media packetization delay, which is present in Voice-over-IP
 (VoIP) applications. In VoIP, the sending side must first fill a packet with encoded digitized speech
 before passing the packet to the Internet. This time to fill a packet—called the packetization delay—can
 be significant and can impact the user-perceived quality of a VoIP call.
 #+END_QUOTE
**** Throughput and bottleneck
     :PROPERTIES:
     :NOTER_PAGE: 72
     :HIGHLIGHT: #s(pdf-highlight 72 ((0.7180428134556575 0.6897031539888683 0.6342507645259938 0.8070500927643784)))
     :END:
 #+BEGIN_QUOTE
 Thus, for this simple
 two-link network, the throughput is min{Rc, Rs}, that is, it is the transmission rate of the bottleneck link.
 Having determined the throughput, we can now approximate the time it takes to transfer a large file of F
 bits from server to client as F/min{Rs, Rc}. For a specific example, suppose you are downloading an MP3
 file of F=32 million bits, the server has a transmission rate of Rs=2 Mbps, and you have an access link
 of Rc=1 Mbps. The time needed to transfer the file is then 32 seconds.
 #+END_QUOTE
**** Java applets: https://computerscience.unicam.it/marcantoni/reti/applet/
**** the constraining factor for throughput in today’s Internet is typically the access network.
     :PROPERTIES:
     :NOTER_PAGE: 73
     :HIGHLIGHT: #s(pdf-highlight 73 ((0.2697247706422018 0.3098330241187384 0.1565749235474006 0.33487940630797774)))
     :END:
**** Throughput approximation
     :PROPERTIES:
     :NOTER_PAGE: 74
     :HIGHLIGHT: #s(pdf-highlight 74 ((0.08440366972477063 0.6892393320964749 0.21590214067278285 0.7068645640074211)))
     :END:
 #+BEGIN_QUOTE
 throughput can simply be approximated as the minimum transmission rate along the path between
 source and destination.
 #+END_QUOTE
*** 1.5 Protocol Layers and Their Service Models
    :PROPERTIES:
    :NOTER_PAGE: 75
    :END:
**** Protocol Layering functions
     :PROPERTIES:
     :NOTER_PAGE: 77
     :HIGHLIGHT: #s(pdf-highlight 77 ((0.6819571865443425 0.35111317254174396 0.6207951070336392 0.49211502782931354)))
     :END:
 #+BEGIN_QUOTE
 We are again interested in
 the services that a layer offers to the layer above—the so-called service model of a layer. Just as in
 the case of our airline example, each layer provides its service by (1) performing certain actions within
 that layer and by (2) using the services of the layer directly below it. For example, the services provided
 by layer n may include reliable delivery of messages from one edge of the network to the other. This
 might be implemented by using an unreliable edge-to-edge message delivery service of layer n−1, and
 adding layer n functionality to detect and retransmit lost messages.
 #+END_QUOTE
**** Internet protocol stack
     :PROPERTIES:
     :NOTER_PAGE: 78
     :HIGHLIGHT: #s(pdf-highlight 78 ((0.08440366972477063 0.4457328385899815 0.15779816513761466 0.5)))
     :END:
 #+BEGIN_QUOTE
 When taken together, the protocols of the various layers are called the protocol stack. The Internet
 protocol stack consists of five layers: the physical, link, network, transport, and application layers.
 #+END_QUOTE
**** application layer
     :PROPERTIES:
     :NOTER_PAGE: 78
     :HIGHLIGHT: #s(pdf-highlight 78 ((0.0801223241590214 0.8353432282003711 0.7333333333333333 0.8803339517625232)))
     :END:
 #+BEGIN_QUOTE
 An application-layer protocol is distributed over multiple end systems, with the application in one end
 system using the protocol to exchange packets of information with the application in another end
 system. We’ll refer to this packet of information at the application layer as a message.
 #+END_QUOTE
**** Disadvantages: layers can have duplicate functionalities, layers might need information from other layer (violates the principle of separation)
     :PROPERTIES:
     :NOTER_PAGE: (78 0.35064935064935066 . 0.04250764525993882)
     :END:
**** transport layer
     :PROPERTIES:
     :NOTER_PAGE: 79
     :HIGHLIGHT: #s(pdf-highlight 79 ((0.07767584097859327 0.055658627087198514 0.20795107033639143 0.10064935064935066)))
     :END:
	 - TCP provides a ­connection-oriented service to its applications.
	 - The UDP protocol provides a connectionless service to its applications.
	 - we’ll refer to a transport-layer packet as a segment.
 #+BEGIN_QUOTE
 The Internet’s transport layer transports application-layer messages between application endpoints. In
 the Internet there are two transport protocols, TCP and UDP, either of which can transport application-
 layer messages.
 #+END_QUOTE
**** Network layer, packets called datagrams, one protocol called IP
     :PROPERTIES:
     :NOTER_PAGE: 79
     :HIGHLIGHT: #s(pdf-highlight 79 ((0.07986309184255562 0.4610726643598616 0.49458071876782655 0.5579584775086506)))
     :END:
 #+BEGIN_QUOTE
 The Internet’s network layer is responsible for moving network-layer packets known as datagrams from
 one host to another.
 ...
 The Internet’s network layer includes the celebrated IP protocol, which defines the fields in the datagram
 as well as how the end systems and routers act on these fields. There is only one IP protocol, and all
 Internet components that have a network layer must run the IP protocol. The Internet’s network layer
 also contains routing protocols that determine the routes that datagrams take between sources and
 destinations. The Internet has many routing protocols.
 #+END_QUOTE
**** Link layer
     :PROPERTIES:
     :NOTER_PAGE: 79
     :HIGHLIGHT: #s(pdf-highlight 79 ((0.0838562464346834 0.736159169550173 0.814033086138049 0.8023356401384083)))
     :END:
 #+BEGIN_QUOTE
 The Internet’s network layer routes a datagram through a series of routers between the source and
 destination. To move a packet from one node (host or router) to the next node in the route, the network
 layer relies on the services of the link layer. In particular, at each node, the network layer passes the
 datagram down to the link layer, which delivers the datagram to the next node along the route.
 #+END_QUOTE
**** Physical layer, protocols dependent on the medium
     :PROPERTIES:
     :NOTER_PAGE: 80
     :HIGHLIGHT: #s(pdf-highlight 80 ((0.8111808328579577 0.37543252595155713 0.132344552196235 0.30839100346020765)))
     :END:
 #+BEGIN_QUOTE
 The protocols in this layer are again link dependent and further depend on the actual transmission
 medium of the link (for example, twisted-pair copper wire, single-mode fiber optics). For example,
 Ethernet has many physical-layer protocols: one for twisted-pair copper wire, another for coaxial cable,
 another for fiber, and so on. In each case, a bit is moved across the link in a different way.
 #+END_QUOTE
**** Crapware of the OSI model: presentation layer and session layer
     :PROPERTIES:
     :NOTER_PAGE: 80
     :HIGHLIGHT: #s(pdf-highlight 80 ((0.08157444381061038 0.7768166089965398 0.749001711351968 0.9126297577854672)))
     :END:
 #+BEGIN_QUOTE
 Thus, let’s consider the two additional layers present in the OSI reference model—the presentation layer
 and the session layer. The role of the presentation layer is to provide services that allow communicating
 applications to interpret the meaning of data exchanged. These services include data compression and
 data encryption (which are self-explanatory) as well as data description (which frees the applications
 from having to worry about the internal format in which data are represented/stored—formats that may
 differ from one computer to another). The session layer provides for delimiting and synchronization of
 data exchange, including the means to build a checkpointing and recovery scheme.
 #+END_QUOTE
**** Protocols of the link layer
     :PROPERTIES:
     :NOTER_PAGE: (80 0.05709342560553633 . 0.22589845978322873)
     :HIGHLIGHT: #s(pdf-highlight 80 ((0.22589845978322873 0.05709342560553633 0.719908727895037 0.058823529411764705)))
     :END:
 ``Ethernet, WiFi, and the cable access network’s DOCSIS protocol.''
**** Encapsulation
     :PROPERTIES:
     :NOTER_PAGE: 81
     :HIGHLIGHT: #s(pdf-highlight 81 ((0.07472903593839132 0.717128027681661 0.4489446662863662 0.7426470588235294)))
     :END:
 #+BEGIN_QUOTE
 Figure 1.24 Hosts, routers, and link-layer switches; each contains a ­different set of layers,
 reflecting their differences in ­functionality
 #+END_QUOTE
#+DOWNLOADED: screenshot @ 2023-10-28 11:58:10
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_11-58-10_screenshot.png]]

**** Partial stack
     :PROPERTIES:
     :NOTER_PAGE: 81
     :HIGHLIGHT: #s(pdf-highlight 81 ((0.645750142612664 0.8499134948096886 0.19680547632629777 0.8910034602076125)))
     :END:
 #+BEGIN_QUOTE
 But routers and link-layer
 switches do not implement all of the layers in the protocol stack; they typically implement only the
 bottom layers.
 #+END_QUOTE
**** Encapsulation, accumulation of payload fields
     :PROPERTIES:
     :NOTER_PAGE: 82
     :HIGHLIGHT: #s(pdf-highlight 82 ((0.6531660011409013 0.4411764705882353 0.6383342840844266 0.14619377162629757)))
     :END:
 #+BEGIN_QUOTE
 At the sending host, an
 application-layer message (M in Figure 1.24) is passed to the transport layer. In the simplest case,
 the transport layer takes the message and appends additional information (so-called transport-layer
 header information, Ht in Figure 1.24) that will be used by the receiver-side transport layer. The
 application-layer message and the transport-layer header information together constitute the transport-
 layer segment. The transport-layer segment thus encapsulates the application-layer message. The
 added information might include information allowing the receiver-side transport layer to deliver the
 message up to the appropriate application, and error-detection bits that allow the receiver to determine
 whether bits in the message have been changed in route. The transport layer then passes the segment
 to the network layer, which adds network-layer header information (Hn in Figure 1.24) such as source
 and destination end system addresses, creating a network-layer datagram. The datagram is then
 passed to the link layer, which (of course!) will add its own link-layer header information and create a
 link-layer frame. Thus, we see that at each layer, a packet has two types of fields: header fields and a
 payload field. The payload is typically a packet from the layer above.
 #+END_QUOTE
*** 1.6 Networks Under Attack
    :PROPERTIES:
    :NOTER_PAGE: 83
    :END:
**** Botnet
     :PROPERTIES:
     :NOTER_PAGE: 83
     :HIGHLIGHT: #s(pdf-highlight 83 ((0.7529948659440958 0.8321799307958477 0.6491728465487735 0.9078719723183392)))
     :END:
 #+BEGIN_QUOTE
 Our compromised
 host may also be enrolled in a network of thousands of similarly compromised devices, collectively
 known as a botnet, which the bad guys control and leverage for spam e-mail distribution or distributed
 denial-of-service attacks (soon to be discussed) against targeted hosts.
 #+END_QUOTE
**** Viruses and worms
     :PROPERTIES:
     :NOTER_PAGE: 84
     :HIGHLIGHT: #s(pdf-highlight 84 ((0.32230462065031373 0.11807958477508651 0.2236166571591557 0.30276816608996543)))
     :END:
 #+BEGIN_QUOTE
 Viruses are malware that require some form of user interaction to infect
 the user’s device. The classic example is an e-mail attachment containing malicious executable code. If
 a user receives and opens such an attachment, the user inadvertently runs the malware on the device.
 Typically, such e-mail viruses are self-replicating: once executed, the virus may send an identical
 message with an identical malicious attachment to, for example, every recipient in the user’s address
 book. Worms are malware that can enter a device without any explicit user interaction. For example, a
 user may be running a vulnerable network application to which an attacker can send malware. In some
 cases, without any user intervention, the application may accept the malware from the Internet and run
 it, creating a worm.
 #+END_QUOTE
**** DoS attacks
     :PROPERTIES:
     :NOTER_PAGE: 84
     :HIGHLIGHT: #s(pdf-highlight 84 ((0.3525385054192812 0.5506055363321799 0.5151169423844837 0.47923875432525953)))
     :END:
 #+BEGIN_QUOTE
 denial-of-service (DoS) attacks. As the name
 suggests, a DoS attack renders a network, host, or other piece of infrastructure unusable by legitimate
 users. Web servers, e-mail servers, DNS servers (discussed in Chapter 2), and institutional networks
 can all be subject to DoS attacks.
 #+END_QUOTE
**** DoS attacks categories
     :PROPERTIES:
     :NOTER_PAGE: 84
     :HIGHLIGHT: #s(pdf-highlight 84 ((0.08727895037079292 0.6427335640138409 0.8482601254991443 0.8243944636678201)))
     :END:
	 - Vulnerability attack.
	 - Bandwidth flooding. 
	 - Connection flooding. 
**** DDoS attack
     :PROPERTIES:
     :NOTER_PAGE: 85
     :HIGHLIGHT: #s(pdf-highlight 85 ((0.5733029092983457 0.07525951557093426 0.3804905875641757 0.13451557093425606)))
     :END:
 #+BEGIN_QUOTE
 In a distributed DoS (DDoS) attack,
 illustrated in Figure 1.25, the attacker controls multiple sources and has each source blast traffic at the
 target. With this approach, the aggregate traffic rate across all the controlled sources needs to be
 approximately R to cripple the ­service.
 #+END_QUOTE
#+DOWNLOADED: screenshot @ 2023-10-28 11:58:58
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_11-58-58_screenshot.png]]

**** packet sniffer
     :PROPERTIES:
     :NOTER_PAGE: 85
     :HIGHLIGHT: #s(pdf-highlight 85 ((0.6292070735881345 0.8442906574394464 0.14945807187678264 0.9169550173010381)))
     :END:
 #+BEGIN_QUOTE
 packets can contain all kinds of
 sensitive information, including passwords, social security numbers, trade secrets, and private personal
 messages. A passive receiver that records a copy of every packet that flies by is called a packet
 sniffer.
 #+END_QUOTE
**** We will sniff data illegally!
     :PROPERTIES:
     :NOTER_PAGE: 86
     :HIGHLIGHT: #s(pdf-highlight 86 ((0.5533371363377068 0.2586505190311419 0.2738163148887621 0.3070934256055363)))
     :END:
 #+BEGIN_QUOTE
 Professors teaching a networking course have been known to assign lab exercises that involve writing a packet-
 sniffing and application-layer data reconstruction program. Indeed, the Wireshark [Wireshark 2016]
 labs associated with this text (see the introductory Wireshark lab at the end of this chapter) use exactly
 such a packet sniffer!
 #+END_QUOTE
**** Fake packets, IP spoofing
     :PROPERTIES:
     :NOTER_PAGE: 86
     :HIGHLIGHT: #s(pdf-highlight 86 ((0.32686822589845976 0.6842560553633218 0.1990872789503708 0.5938581314878892)))
     :END:
 #+BEGIN_QUOTE
 Imagine the unsuspecting receiver (say an Internet router) who receives such a packet,
 takes the (false) source address as being truthful, and then performs some command embedded in the
 packet’s contents (say modifies its forwarding table). The ability to inject packets into the Internet with a
 false source address is known as IP spoofing, and is but one of many ways in which one user can
 masquerade as another user.
 #+END_QUOTE
*** 1.7 History of Computer Networking and the Internet
    :PROPERTIES:
    :NOTER_PAGE: 88
    :END:
**** How today's TCP, IP and UDP were formed
     :PROPERTIES:
     :NOTER_PAGE: 91
     :HIGHLIGHT: #s(pdf-highlight 91 ((0.30690245293782087 0.2106401384083045 0.13918996006845408 0.3468858131487889)))
     :END:
 #+BEGIN_QUOTE
 The early versions of TCP combined a reliable in-sequence delivery of data
 via end-system retransmission (still part of today’s TCP) with forwarding functions (which today are
 performed by IP). Early experimentation with TCP, combined with the recognition of the importance of
 an unreliable, non-flow-controlled, end-to-end transport service for applications such as packetized
 voice, led to the separation of IP out of TCP and the development of the UDP protocol. The three key
 Internet protocols that we see today—TCP, UDP, and IP—were conceptually in place by the end of the
 1970s.
 #+END_QUOTE
**** How today's Ethernet and LAN were invented
     :PROPERTIES:
     :NOTER_PAGE: 91
     :HIGHLIGHT: #s(pdf-highlight 91 ((0.17056474614945807 0.4139273356401384 0.4500855675984027 0.6115916955017301)))
     :END:
 #+BEGIN_QUOTE
 In Hawaii, Norman Abramson was developing ALOHAnet, a packet-based radio network that
 allowed multiple remote sites on the Hawaiian Islands to communicate with each other. The ALOHA
 protocol [Abramson 1970] was the first multiple-access protocol, allowing geographically distributed
 users to share a single broadcast communication medium (a radio ­frequency). Metcalfe and Boggs
 built on Abramson’s multiple-access protocol work when they developed the Ethernet protocol [Metcalfe
 1976] for wire-based shared broadcast networks. Interestingly, Metcalfe and Boggs’ Ethernet protocol
 was motivated by the need to connect multiple PCs, printers, and shared disks [Perkins 1994]. Twenty-
 five years ago, well before the PC revolution and the explosion of networks, Metcalfe and Boggs were
 laying the foundation for today’s PC LANs.
 #+END_QUOTE
**** French were the first regular people that got access to internet, for free
     :PROPERTIES:
     :NOTER_PAGE: 92
     :HIGHLIGHT: #s(pdf-highlight 92 ((0.7204791785510553 0.4619377162629758 0.08214489446662863 0.24740484429065746)))
     :END:
 #+BEGIN_QUOTE
 Paralleling this development of the ARPAnet (which was for the most part a US effort), in the early
 1980s the French launched the Minitel project, an ambitious plan to bring data networking into
 everyone’s home. Sponsored by the French government, the Minitel system consisted of a public
 packet-switched network (based on the X.25 protocol suite), Minitel servers, and inexpensive terminals
 with built-in low-speed modems. The Minitel became a huge success in 1984 when the French
 government gave away a free Minitel terminal to each French household that wanted one. Minitel sites
 included free sites—such as a telephone directory site—as well as private sites, which collected a
 usage-based fee from each user. At its peak in the mid 1990s, it offered more than 20,000 services,
 ranging from home banking to specialized research databases. The Minitel was in a large proportion of
 French homes 10 years before most Americans had ever heard of the Internet.
 #+END_QUOTE
** Chapter 2 Application Layer
   :PROPERTIES:
   :NOTER_PAGE: 112
   :END:
*** 2.1 Principles of Network Applications
    :PROPERTIES:
    :NOTER_PAGE: 114
    :END:
**** Killer features of the internet
     :PROPERTIES:
     :NOTER_PAGE: 112
     :HIGHLIGHT: #s(pdf-highlight 112 ((0.08157444381061038 0.4195501730103806 0.3029092983456931 0.5112456747404844)))
     :END:
 #+BEGIN_QUOTE
 Internet applications include the classic text-based applications that became popular in the 1970s and
 1980s: text e-mail, remote access to computers, file transfers, and newsgroups. They include the killer
 application of the mid-1990s, the World Wide Web, encompassing Web surfing, search, and electronic
 commerce. They include instant messaging and P2P file sharing, the two killer applications introduced
 at the end of the millennium.
 #+END_QUOTE

**** Software is developed only for the application layer
     :PROPERTIES:
     :NOTER_PAGE: 114
     :HIGHLIGHT: #s(pdf-highlight 114 ((0.690815744438106 0.49134948096885817 0.8220193953223046 0.6241349480968859)))
     :END:
 #+BEGIN_QUOTE
 Importantly, you do not
 need to write software that runs on network-core devices, such as routers or link-layer switches. Even if
 you wanted to write application software for these network-core devices, you wouldn’t be able to do so.
 As we learned in Chapter 1, and as shown earlier in Figure 1.24, network-core devices do not function
 at the application layer but instead function at lower layers—specifically at the network layer and below.
 This basic design—namely, confining application software to the end systems—as shown in Figure 2.1,
 has facilitated the rapid development and deployment of a vast array of network applications.
 #+END_QUOTE
#+DOWNLOADED: screenshot @ 2023-10-28 12:05:40
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_12-05-40_screenshot.png]]

**** Don't confuse network architecture and application architecture
     :PROPERTIES:
     :NOTER_PAGE: 116
     :HIGHLIGHT: #s(pdf-highlight 116 ((0.09127210496292071 0.04195501730103807 0.7541357672561323 0.11980968858131488)))
     :END:
 #+BEGIN_QUOTE
 Before diving into software coding, you should have a broad architectural plan for your application. Keep
 in mind that an application’s architecture is distinctly different from the network architecture (e.g., the
 five-layer Internet architecture discussed in Chapter 1). From the application developer’s perspective,
 the network architecture is fixed and provides a specific set of services to applications.
 #+END_QUOTE
**** client & server roles in p2p
     :PROPERTIES:
     :NOTER_PAGE: 119
     :HIGHLIGHT: #s(pdf-highlight 119 ((0.2977752424415288 0.11678200692041522 0.6423274386765544 0.14100346020761245)))
     :END:
 ``With P2P file sharing, the peer that is downloading''
**** Client & server definitions
     :PROPERTIES:
     :NOTER_PAGE: 119
     :HIGHLIGHT: #s(pdf-highlight 119 ((0.11409013120365087 0.32698961937716264 0.8146035367940673 0.3680795847750865)))
     :END:
 #+BEGIN_QUOTE
 In the context of a communication session between a pair of processes, the process that initiates the
 communication (that is, initially contacts the other process at the beginning of the session) is labeled
 as the client. The process that waits to be contacted to begin the session is the server.
 #+END_QUOTE
**** Socket
     :PROPERTIES:
     :NOTER_PAGE: 119
     :HIGHLIGHT: #s(pdf-highlight 119 ((0.34341129492298916 0.6604671280276817 0.48830576155162575 0.689446366782007)))
     :END:
 #+BEGIN_QUOTE
 A process sends messages into, and receives messages from, the
 network through a software interface called a socket.
 #+END_QUOTE
**** Socket is an API
     :PROPERTIES:
     :NOTER_PAGE: 119
     :HIGHLIGHT: #s(pdf-highlight 119 ((0.3553907586993725 0.9104671280276817 0.8379920136908157 0.9338235294117647)))
     :END:
 #+BEGIN_QUOTE
 a socket is the interface between the application layer and the
 transport layer within a host. It is also referred to as the Application Programming Interface (API) between the application and the network, since the socket is the programming interface with which
 network applications are built. The application developer has control of everything on the application-
 layer side of the socket but has little control of the transport-layer side of the socket.
 #+END_QUOTE
**** Allowed tweaks in transport layer
     :PROPERTIES:
     :NOTER_PAGE: 120
     :HIGHLIGHT: #s(pdf-highlight 120 ((0.7552766685681688 0.0990484429065744 0.19794637763833428 0.16046712802768168)))
     :END:
 #+BEGIN_QUOTE
 The only control
 that the application developer has on the transport-layer side is (1) the choice of transport protocol and
 (2) perhaps the ability to fix a few transport-layer parameters such as maximum buffer and maximum
 segment sizes
 #+END_QUOTE
**** IP and port
     :PROPERTIES:
     :NOTER_PAGE: 120
     :HIGHLIGHT: #s(pdf-highlight 120 ((0.07016543069024529 0.7512975778546713 0.7626925270964061 0.7802768166089966)))
     :END:
 #+BEGIN_QUOTE
 To identify the receiving process, two pieces of information need to be specified: (1) the address of the
 host and (2) an identifier that specifies the receiving process in the destination host.
 #+END_QUOTE
**** IP address is a 32-bit quantity
     :PROPERTIES:
     :NOTER_PAGE: 120
     :HIGHLIGHT: #s(pdf-highlight 120 ((0.49629207073588133 0.8481833910034602 0.7227609811751283 0.8507785467128028)))
     :END:
**** List of standard ports
     :PROPERTIES:
     :NOTER_PAGE: 121
     :HIGHLIGHT: #s(pdf-highlight 121 ((0.5567598402738163 0.10164359861591696 0.6685681688533941 0.11764705882352941)))
     :END:
 ``www.iana.org.''
**** services of a transport layer
     :PROPERTIES:
     :NOTER_PAGE: 121
     :HIGHLIGHT: #s(pdf-highlight 121 ((0.08043354249857387 0.5333044982698962 0.20193953223046204 0.5882352941176471)))
     :END:
 #+BEGIN_QUOTE
 What are the services that a transport-layer protocol can offer to applications invoking it? We can
 broadly classify the possible services along four dimensions: reliable data transfer, throughput, timing,
 and security.
 #+END_QUOTE
**** Throughput can be guaranteed by transport layer
     :PROPERTIES:
     :NOTER_PAGE: 122
     :HIGHLIGHT: #s(pdf-highlight 122 ((0.6491728465487735 0.3070934256055363 0.6891043924700513 0.38321799307958476)))
     :END:
 #+BEGIN_QUOTE
 natural service that a transport-
 layer protocol could provide, namely, guaranteed available throughput at some specified rate. With such
 a service, the application could request a guaranteed throughput of r bits/sec, and the transport protocol
 would then ensure that the available throughput is always at least r bits/sec.
 #+END_QUOTE
**** Elastic applications
     :PROPERTIES:
     :NOTER_PAGE: 122
     :HIGHLIGHT: #s(pdf-highlight 122 ((0.713063320022818 0.6189446366782008 0.6879634911580148 0.6911764705882353)))
     :END:
 #+BEGIN_QUOTE
 elastic applications can
 make use of as much, or as little, throughput as happens to be available. Electronic mail, file transfer,
 and Web transfers are all elastic applications. Of course, the more throughput, the better. There’san
 adage that says that one cannot be too rich, too thin, or have too much throughput!
 #+END_QUOTE
**** A transport-layer protocol can also provide timing guarantees.
     :PROPERTIES:
     :NOTER_PAGE: 122
     :HIGHLIGHT: #s(pdf-highlight 122 ((0.07701083856246434 0.7807093425605537 0.5670279520821448 0.7742214532871973)))
     :END:
**** security in transport layer
     :PROPERTIES:
     :NOTER_PAGE: 123
     :HIGHLIGHT: #s(pdf-highlight 123 ((0.8009127210496292 0.189878892733564 0.5807187678265829 0.2876297577854671)))
     :END:
 #+BEGIN_QUOTE
 For example,
 in the sending host, a transport protocol can encrypt all data transmitted by the sending process, and in
 the receiving host, the transport-layer protocol can decrypt the data before delivering the data to the
 receiving process. Such a service would provide confidentiality between the two processes, even if the
 data is somehow observed between sending and receiving processes.
 #+END_QUOTE
**** TCP's connection-oriented service
     :PROPERTIES:
     :NOTER_PAGE: 123
     :HIGHLIGHT: #s(pdf-highlight 123 ((0.10895607529948659 0.7634083044982699 0.8425556189389617 0.8416955017301039)))
     :END:
 #+BEGIN_QUOTE
 Connection-oriented service. TCP has the client and server exchange transport-layer control
 information with each other before the application-level messages begin to flow. This so-called
 handshaking procedure alerts the client and server, allowing them to prepare for an onslaught of
 packets. After the handshaking phase, a TCP connection is said to exist between the sockets
 #+END_QUOTE
**** TCP's reliable data transfer service
     :PROPERTIES:
     :NOTER_PAGE: 124
     :HIGHLIGHT: #s(pdf-highlight 124 ((0.11409013120365087 0.4930795847750865 0.40102681118083283 0.5618512110726643)))
     :END:
 #+BEGIN_QUOTE
 Reliable data transfer service. The communicating processes can rely on TCP to deliver all data
 sent without error and in the proper order. When one side of the application passes a stream of
 bytes into a socket, it can count on TCP to deliver the same stream of bytes to the receiving socket,
 with no missing or duplicate bytes.
 #+END_QUOTE
**** TCP is not egoistic
     :PROPERTIES:
     :NOTER_PAGE: 124
     :HIGHLIGHT: #s(pdf-highlight 124 ((0.08841985168282943 0.6042387543252595 0.2316029663434113 0.6764705882352942)))
     :END:
 #+BEGIN_QUOTE
 TCP also includes a congestion-control mechanism, a service for the general welfare of the Internet
 rather than for the direct benefit of the communicating processes. The TCP congestion-control
 mechanism throttles a sending process (client or server) when the network is congested between
 sender and receiver.
 #+END_QUOTE
**** TCP-enhanced-with-SSL can use encryption
     :PROPERTIES:
     :NOTER_PAGE: 124
     :HIGHLIGHT: #s(pdf-highlight 124 ((0.8043354249857387 0.9273356401384083 0.12892184826012548 0.7993079584775087)))
     :END:
 #+BEGIN_QUOTE
 Neither TCP nor UDP provides any encryption—the data that the sending process passes into
 its socket is the same data that travels over the network to the destination process. So, for
 example, if the sending process sends a password in cleartext (i.e., unencrypted) into its socket,
 the cleartext password will travel over all the links between sender and receiver, potentially
 getting sniffed and discovered at any of the intervening links. Because privacy and other security
 issues have become critical for many applications, the Internet community has developed an
 enhancement for TCP, called Secure Sockets Layer (SSL). TCP-enhanced-with-SSL
 #+END_QUOTE
**** Application layer protocol defines:
     :PROPERTIES:
     :NOTER_PAGE: 127
     :HIGHLIGHT: #s(pdf-highlight 127 ((0.10096976611523102 0.05147058823529412 0.8357102110667427 0.15484429065743946)))
     :END:
	 - The types of messages exchanged, for example, request messages and response messages
	 - The syntax of the various message types, such as the fields in the message and how the fields are delineated
	 - The semantics of the fields, that is, the meaning of the information in the fields
	 - Rules for determining when and how a process sends messages and responds to messages
**** Public vs proprietary application layer protocols
     :PROPERTIES:
     :NOTER_PAGE: 127
     :HIGHLIGHT: #s(pdf-highlight 127 ((0.2549914432401597 0.231401384083045 0.5755847119224187 0.3023356401384083)))
     :END:
 #+BEGIN_QUOTE
 If a browser developer follows the rules of the HTTP RFC, the browser will be able
 to retrieve Web pages from any Web server that has also followed the rules of the HTTP RFC. Many
 other application-layer protocols are proprietary and intentionally not available in the public domain. For
 example, Skype uses proprietary application-layer protocols.
 #+END_QUOTE
**** Application-layer protocol < Network application
     :PROPERTIES:
     :NOTER_PAGE: 127
     :HIGHLIGHT: #s(pdf-highlight 127 ((0.08100399315459213 0.3438581314878893 0.34854535082715343 0.39273356401384085)))
     :END:
 #+BEGIN_QUOTE
 It is important to distinguish between network applications and application-layer protocols. An
 application-layer protocol is only one piece of a network application (albeit, a very important piece of the
 application from our point of view!).
 ...
 The Web’s application-layer protocol, HTTP,
 defines the format and sequence of messages exchanged between browser and Web server. Thus,
 HTTP is only one piece (albeit, an important piece) of the Web application.
 ...
 The principal application-layer protocol
 for electronic mail is SMTP (Simple Mail Transfer Protocol) [RFC 5321]. Thus, e-mail’s principal
 application-layer protocol, SMTP, is only one piece (albeit an important piece) of the e-mail application.
 #+END_QUOTE
*** 2.2 The Web and HTTP
    :PROPERTIES:
    :NOTER_PAGE: 129
    :END:
**** HTTP is implemented in two programs: a client program and a server program.
	 :PROPERTIES:
	 :NOTER_PAGE: 129
	 :HIGHLIGHT: #s(pdf-highlight 129 ((0.48408408408408404 0.7477231329690346 0.3279279279279279 0.7759562841530054)))
	 :END:
**** HTTP uses TCP as its underlying transport protocol
	 :PROPERTIES:
	 :NOTER_PAGE: 130
	 :HIGHLIGHT: #s(pdf-highlight 130 ((0.08588588588588589 0.5186703096539163 0.48648648648648646 0.5214025500910747)))
	 :END:
**** Advantages of layered architecture
	 :PROPERTIES:
	 :NOTER_PAGE: 131
	 :HIGHLIGHT: #s(pdf-highlight 131 ((0.23243243243243242 0.24089253187613843 0.584984984984985 0.27641165755919855)))
	 :END:
 #+BEGIN_QUOTE
 great advantages of a layered architecture—HTTP need not worry about lost data or
 the details of how TCP recovers from loss or reordering of data within the network. That is the job of
 TCP and the protocols in the lower layers of the protocol stack.
 #+END_QUOTE
**** HTTP - stateless protocol
	 :PROPERTIES:
	 :NOTER_PAGE: 131
	 :HIGHLIGHT: #s(pdf-highlight 131 ((0.3111111111111111 0.35382513661202186 0.7429429429429429 0.4157559198542805)))
	 :END:
 #+BEGIN_QUOTE
 If a particular client asks for the same object twice in a period of a few
 seconds, the server does not respond by saying that it just served the object to the client; instead, the
 server resends the object, as it has completely forgotten what it did earlier. Because an HTTP server
 maintains no information about the clients, HTTP is said to be a stateless protocol.
 #+END_QUOTE
**** Non-persistent and persistent connections
	 :PROPERTIES:
	 :NOTER_PAGE: 131
	 :HIGHLIGHT: #s(pdf-highlight 131 ((0.47327327327327323 0.6703096539162113 0.7663663663663663 0.7654826958105647)))
	 :END:
 #+BEGIN_QUOTE
 When this client-server interaction is taking place over
 TCP, the application developer needs to make an important decision—should each request/response
 pair be sent over a separate TCP connection, or should all of the requests and their corresponding
 responses be sent over the same TCP connection? In the former approach, the application is said to
 use non-persistent connections; and in the latter approach, persistent connections.
 #+END_QUOTE
**** HTTP is persistent by default
	 :PROPERTIES:
	 :NOTER_PAGE: 131
	 :HIGHLIGHT: #s(pdf-highlight 131 ((0.4066066066066066 0.8328779599271402 0.8072072072072072 0.8597449908925319)))
	 :END:
 #+BEGIN_QUOTE
 Although HTTP uses persistent connections in its default
 mode, HTTP clients and servers can be configured to use non-persistent connections instead.
 #+END_QUOTE
**** port number 80, which is the default port number for HTTP.
	 :PROPERTIES:
	 :NOTER_PAGE: 132
	 :HIGHLIGHT: #s(pdf-highlight 132 ((0.14654654654654653 0.3214936247723133 0.5855855855855856 0.3173952641165756)))
	 :END:
**** HTTP sees the world ugly
	 :PROPERTIES:
	 :NOTER_PAGE: 132
	 :HIGHLIGHT: #s(pdf-highlight 132 ((0.6606606606606606 0.6771402550091075 0.15495495495495495 0.7682149362477231)))
	 :END:
 #+BEGIN_QUOTE
 Two different browsers may
 interpret (that is, display to the user) a Web page in somewhat different ways. HTTP has nothing to do
 with how a Web page is interpreted by a client. The HTTP specifications ([RFC 1945] and [RFC 2616])
 define only the communication protocol between the client HTTP program and the server HTTP
 program.
 #+END_QUOTE
**** round-trip time
	 :PROPERTIES:
	 :NOTER_PAGE: 133
	 :HIGHLIGHT: #s(pdf-highlight 133 ((0.26666666666666666 0.2540983606557377 0.4168168168168168 0.28688524590163933)))
	 :END:
 #+BEGIN_QUOTE
 round-trip time (RTT), which is the time it takes for a small packet to travel from
 client to server and then back to the client. The RTT includes packet-propagation delays, packet-
 queuing delays in intermediate routers and switches, and packet-processing delays.
 #+END_QUOTE
****  Figure 2.7 Back-of-the-envelope calculation for the time needed to request and receive an HTML file
	 :PROPERTIES:
	 :NOTER_PAGE: 134
	 :HIGHLIGHT: #s(pdf-highlight 134 ((0.08348348348348349 0.052823315118397086 0.1135135135135135 0.0714936247723133)))
	 :END:

#+DOWNLOADED: screenshot @ 2023-10-28 12:07:00
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_12-07-00_screenshot.png]]

**** Typical HTTP request message
	 :PROPERTIES:
	 :NOTER_PAGE: 135
	 :HIGHLIGHT: #s(pdf-highlight 135 ((0.12432432432432432 0.14571948998178508 0.3261261261261261 0.2522768670309654)))
	 :END:
 #+BEGIN_QUOTE
 GET /somedir/page.html HTTP/1.1
 Host: www.someschool.edu
 Connection: close
 User-agent: Mozilla/5.0
 Accept-language: fr
 #+END_QUOTE
**** Notes for page 135
	 :PROPERTIES:
	 :NOTER_PAGE: 135
	 :HIGHLIGHT: #s(pdf-highlight 135 ((0.08288288288288288 0.40528233151183973 0.22522522522522523 0.4266848816029144)))
	 :END:
 #+BEGIN_QUOTE
 The first line of an HTTP request message is called the request line; the subsequent lines are called
 the header lines.
 #+END_QUOTE
**** Host specification is always required
	 :PROPERTIES:
	 :NOTER_PAGE: 135
	 :HIGHLIGHT: #s(pdf-highlight 135 ((0.4816816816816817 0.5897085610200364 0.6048048048048048 0.6598360655737705)))
	 :END:
 #+BEGIN_QUOTE
 The header line Host: www.someschool.edu
 specifies the host on which the object resides. You might think that this header line is unnecessary, as
 there is already a TCP connection in place to the host. But, as we’ll see in Section 2.2.5, the information
 provided by the host header line is required by Web proxy caches.
 #+END_QUOTE
**** User-agent
	 :PROPERTIES:
	 :NOTER_PAGE: 135
	 :HIGHLIGHT: #s(pdf-highlight 135 ((0.8156156156156156 0.7071948998178507 0.4204204204204204 0.7946265938069217)))
	 :END:
 #+BEGIN_QUOTE
 The User-
 agent: header line specifies the user agent, that is, the browser type that is making the request to the
 server. Here the user agent is Mozilla/5.0, a Firefox browser. This header line is useful because the
 server can actually send different versions of the same object to different types of user agents. (Each of
 the versions is addressed by the same URL.)
 #+END_QUOTE
**** GET and POST methods
	 :PROPERTIES:
	 :NOTER_PAGE: 136
	 :HIGHLIGHT: #s(pdf-highlight 136 ((0.1987987987987988 0.050546448087431695 0.5591591591591591 0.5664845173041895)))
	 :END:
 #+BEGIN_QUOTE
 after the header lines (and the additional carriage return and line feed) there is an “entity
 body.” The entity body is empty with the GET method, but is used with the POST method. An HTTP
 client often uses the POST method when the user fills out a form—for example, when a user provides
 search words to a search engine. With a POST message, the user is still requesting a Web page from
 the server, but the specific contents of the Web page depend on what the user entered into the form fields. If the value of the method field is POST , then the
 entity body contains what the user entered into the form fields.
 #+END_QUOTE
**** GET can be used instead of POST
	 :PROPERTIES:
	 :NOTER_PAGE: 136
	 :HIGHLIGHT: #s(pdf-highlight 136 ((0.08708708708708708 0.6083788706739527 0.47807807807807806 0.7240437158469946)))
	 :END:
 #+BEGIN_QUOTE
 We would be remiss if we didn’t mention that a request generated with a form does not necessarily use
 the POST method. Instead, HTML forms often use the GET method and include the inputted data (in
 the form fields) in the requested URL. For example, if a form uses the GET method, has two fields, and
 the inputs to the two fields are monkeys and bananas , then the URL will have the structure
 www.somesite.com/animalsearch?monkeys&bananas . In your day-to-day Web surfing, you
 have probably noticed extended URLs of this sort.
 #+END_QUOTE
**** HEAD is for faster responses
	 :PROPERTIES:
	 :NOTER_PAGE: 136
	 :HIGHLIGHT: #s(pdf-highlight 136 ((0.08468468468468468 0.7795992714025501 0.47927927927927927 0.819672131147541)))
	 :END:
 #+BEGIN_QUOTE
 The HEAD method is similar to the GET method. When a server receives a request with the HEAD
 method, it responds with an HTTP message but it leaves out the requested object. Application
 developers often use the HEAD method for debugging.
 #+END_QUOTE
**** PUT for upload
	 :PROPERTIES:
	 :NOTER_PAGE: 136
	 :HIGHLIGHT: #s(pdf-highlight 136 ((0.5231231231231231 0.8246812386156649 0.8984984984984985 0.8629326047358834)))
	 :END:
 #+BEGIN_QUOTE
 The PUT method is often used in conjunction
 with Web publishing tools. It allows a user to upload an object to a specific path (directory) on a specific
 Web server. The PUT method is also used by applications that need to upload objects to Web servers.
 #+END_QUOTE
**** Why would you DELETE?
	 :PROPERTIES:
	 :NOTER_PAGE: 136
	 :HIGHLIGHT: #s(pdf-highlight 136 ((0.08708708708708708 0.8966302367941712 0.781981981981982 0.9153005464480874)))
	 :END:
 #+BEGIN_QUOTE
 The DELETE method allows a user, or an application, to delete an object on a Web server.
 #+END_QUOTE
**** Typical HTTP response message
	 :PROPERTIES:
	 :NOTER_PAGE: 137
	 :HIGHLIGHT: #s(pdf-highlight 137 ((0.12192192192192192 0.16757741347905283 0.46846846846846846 0.33105646630236796)))
	 :END:
 #+BEGIN_QUOTE
 HTTP/1.1 200 OK
 Connection: close
 Date: Tue, 18 Aug 2015 15:44:04 GMT
 Server: Apache/2.2.3 (CentOS)
 Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
 Content-Length: 6821
 Content-Type: text/html
 (data data data data data ...)
 #+END_QUOTE

 #+BEGIN_QUOTE
 It has three sections: an initial status line, six
 header lines, and then the entity body.
 #+END_QUOTE
**** Date header
	 :PROPERTIES:
	 :NOTER_PAGE: 137
	 :HIGHLIGHT: #s(pdf-highlight 137 ((0.6984984984984984 0.5906193078324226 0.15315315315315314 0.6826047358834244)))
	 :END:
 #+BEGIN_QUOTE
 The Date: header line
 indicates the time and date when the HTTP response was created and sent by the server. Note that this
 is not the time when the object was created or last modified; it is the time when the server retrieves the
 object from its file system, inserts the object into the response message, and sends the response
 message.
 #+END_QUOTE
**** Last-Modified is important
	 :PROPERTIES:
	 :NOTER_PAGE: 137
	 :HIGHLIGHT: #s(pdf-highlight 137 ((0.869069069069069 0.732695810564663 0.6732732732732732 0.7836976320582878)))
	 :END:
 #+BEGIN_QUOTE
 The
 Last-Modified: header, which we will soon cover in more detail, is critical for object caching, both in
 the local client and in network cache servers (also known as proxy servers).
 #+END_QUOTE
**** Possible phrases in status line
	 :PROPERTIES:
	 :NOTER_PAGE: 138
	 :HIGHLIGHT: #s(pdf-highlight 138 ((0.12132132132132131 0.12158469945355191 0.31771771771771773 0.23178506375227687)))
	 :END:
 #+BEGIN_QUOTE
 200 OK: Request succeeded and the information is returned in the response.
 301 Moved Permanently: Requested object has been permanently moved; the new URL is
 specified in Location : header of the response message. The client software will automatically
 retrieve the new URL.
 400 Bad Request: This is a generic error code indicating that the request could not be
 understood by the server.
 404 Not Found: The requested document does not exist on this server.
 505 HTTP Version Not Supported: The requested HTTP protocol version is not supported
 by the server.
 #+END_QUOTE
**** Cookies
	 :PROPERTIES:
	 :NOTER_PAGE: 139
	 :HIGHLIGHT: #s(pdf-highlight 139 ((0.3831831831831832 0.8424408014571949 0.48108108108108105 0.8570127504553734)))
	 :END:
 #+BEGIN_QUOTE
 Cookies, defined in [RFC 6265], allow sites to keep track of users.
 Most major commercial Web sites use cookies today.
 #+END_QUOTE
**** Cookie compnents
	 :PROPERTIES:
	 :NOTER_PAGE: 139
	 :HIGHLIGHT: #s(pdf-highlight 139 ((0.2912912912912913 0.9043715846994536 0.9243243243243243 0.9294171220400729)))
	 :END:
	 1) a cookie header line in the HTTP response message;
	 2) a cookie header line in the HTTP request message;
	 3) a cookie file kept on the user’s end system and managed by the user’s browser; 
	 4) a back-end database at the Web site.
**** Figure 2.10 Keeping user state with cookies
	 :PROPERTIES:
	 :NOTER_PAGE: 141
	 :HIGHLIGHT: #s(pdf-highlight 141 ((0.08288288288288288 0.6516393442622951 0.457057057057057 0.6530054644808743)))
	 :END:
#+DOWNLOADED: screenshot @ 2023-10-28 12:07:51
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_12-07-51_screenshot.png]]

**** Web cache, proxy server
	 :PROPERTIES:
	 :NOTER_PAGE: 142
	 :HIGHLIGHT: #s(pdf-highlight 142 ((0.08288288288288288 0.6680327868852459 0.3099099099099099 0.714936247723133)))
	 :END:
 #+BEGIN_QUOTE
 A Web cache—also called a proxy server—is a network entity that satisfies HTTP requests on the
 behalf of an origin Web server. The Web cache has its own disk storage and keeps copies of recently
 requested objects in this storage.
 #+END_QUOTE
**** Cache is both server and client
	 :PROPERTIES:
	 :NOTER_PAGE: 143
	 :HIGHLIGHT: #s(pdf-highlight 143 ((0.07567567567567567 0.581511839708561 0.2948948948948949 0.6329690346083788)))
	 :END:
 #+BEGIN_QUOTE
 Note that a cache is both a server and a client at the same time. When it receives requests from and
 sends responses to a browser, it is a server. When it sends requests to and receives responses from an
 origin server, it is a client.
 #+END_QUOTE
**** Advatanges of deployment of web caching
	 :PROPERTIES:
	 :NOTER_PAGE: 143
	 :HIGHLIGHT: #s(pdf-highlight 143 ((0.6186186186186186 0.7841530054644809 0.833033033033033 0.8346994535519126)))
	 :END:
 #+BEGIN_QUOTE
 First, a Web cache can substantially
 reduce the response time for a client request, particularly if the bottleneck bandwidth between the client
 and the origin server is much less than the bottleneck bandwidth between the client and the cache.
 #+END_QUOTE

 #+BEGIN_QUOTE
 Second,
 as we will soon illustrate with an example, Web caches can substantially reduce traffic on an institution’s
 access link to the Internet. By reducing traffic, the institution (for example, a company or a university)
 does not have to upgrade bandwidth as quickly, thereby reducing costs.
 #+END_QUOTE
**** Internet delay
	 :PROPERTIES:
	 :NOTER_PAGE: 144
	 :HIGHLIGHT: #s(pdf-highlight 144 ((0.6456456456456456 0.3529143897996357 0.4708708708708709 0.2809653916211293)))
	 :END:
 #+BEGIN_QUOTE
 Also suppose that the amount of time it takes from when
 the router on the Internet side of the access link in Figure 2.12 forwards an HTTP request (within an IP
 datagram) until it receives the response (typically within many IP datagrams) is two seconds on
 average. Informally, we refer to this last delay as the “Internet delay.”
 #+END_QUOTE
**** Figure 2.12 Bottleneck between an institutional network and the Internet
	 :PROPERTIES:
	 :NOTER_PAGE: 144
	 :HIGHLIGHT: #s(pdf-highlight 144 ((0.08168168168168168 0.8538251366120219 0.7195195195195195 0.8506375227686703)))
	 :END:
#+DOWNLOADED: screenshot @ 2023-10-28 12:08:25
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_12-08-25_screenshot.png]]

**** Total response time
	 :PROPERTIES:
	 :NOTER_PAGE: 144
	 :HIGHLIGHT: #s(pdf-highlight 144 ((0.06846846846846846 0.9139344262295082 0.9243243243243243 0.9581056466302368)))
	 :END:
 #+BEGIN_QUOTE
 The total response time—that is, the time from the browser’s request of an object until its receipt of the
 object—is the sum of the LAN delay, the access delay (that is, the delay between the two routers), and the Internet delay.
 #+END_QUOTE
**** Hit rates
	 :PROPERTIES:
	 :NOTER_PAGE: 145
	 :HIGHLIGHT: #s(pdf-highlight 145 ((0.6336336336336336 0.5491803278688525 0.6588588588588589 0.5705828779599271)))
	 :END:
 #+BEGIN_QUOTE
 Hit rates—the fraction of requests
 that are satisfied by a cache— typically range from 0.2 to 0.7 in practice.
 #+END_QUOTE
**** CDNs are web caches on steroids
	 :PROPERTIES:
	 :NOTER_PAGE: 146
	 :HIGHLIGHT: #s(pdf-highlight 146 ((0.08408408408408408 0.6826047358834244 0.3075075075075075 0.7122040072859745)))
	 :END:
 #+BEGIN_QUOTE
 Through the use of Content Distribution Networks (CDNs), Web caches are increasingly playing an
 important role in the Internet. A CDN company installs many geographically distributed caches
 throughout the Internet, thereby localizing much of the traffic. There are shared CDNs (such as Akamai
 and Limelight) and dedicated CDNs (such as Google and Netflix). We will discuss CDNs in more detail
 in Section 2.6.
 #+END_QUOTE
**** Conditional GET
	 :PROPERTIES:
	 :NOTER_PAGE: 147
	 :HIGHLIGHT: #s(pdf-highlight 147 ((0.1135135135135135 0.7158469945355191 0.6384384384384384 0.7568306010928961)))
	 :END:
 #+BEGIN_QUOTE
 GET /fruit/kiwi.gif HTTP/1.1
 
 Host: www.exotiquecuisine.com
 
 If-modified-since: Wed, 9 Sep 2015 09:23:24
 #+END_QUOTE

 #+BEGIN_QUOTE
 HTTP/1.1 304 Not Modified
 
 Date: Sat, 10 Oct 2015 15:39:29
 
 Server: Apache/1.3.0 (Unix)
 
 (empty entity body)
 #+END_QUOTE
*** 2.3 Electronic Mail in the Internet
    :PROPERTIES:
    :NOTER_PAGE: 149
    :END:
**** user agents, mail servers, and the Simple Mail Transfer Protocol (SMTP).
	 :PROPERTIES:
	 :NOTER_PAGE: 149
	 :HIGHLIGHT: #s(pdf-highlight 149 ((0.28648648648648645 0.5163934426229508 0.8738738738738738 0.5186703096539163)))
	 :END:
**** Figure 2.14 A high-level view of the Internet e-mail system
	 :PROPERTIES:
	 :NOTER_PAGE: 150
	 :HIGHLIGHT: #s(pdf-highlight 150 ((0.08108108108108107 0.5614754098360656 0.584984984984985 0.5765027322404371)))
	 :END:

#+DOWNLOADED: screenshot @ 2023-10-28 12:08:42
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_12-08-42_screenshot.png]]

**** SMTP both client and server
	 :PROPERTIES:
	 :NOTER_PAGE: 150
	 :HIGHLIGHT: #s(pdf-highlight 150 ((0.4072072072072072 0.9239526411657559 0.3993993993993994 0.8820582877959927)))
	 :END:
 #+BEGIN_QUOTE
 SMTP has two sides: a client side, which executes on the sender’s
 mail server, and a server side, which executes on the recipient’s mail server. Both the client and server
 sides of SMTP run on every mail server.
 #+END_QUOTE

 #+BEGIN_QUOTE
 When a mail server sends mail to other mail servers, it acts as
 an SMTP client. When a mail server receives mail from other mail servers, it acts as an SMTP server.
 #+END_QUOTE
**** SMTP is legacy
	 :PROPERTIES:
	 :NOTER_PAGE: 151
	 :HIGHLIGHT: #s(pdf-highlight 151 ((0.08948948948948948 0.24681238615664844 0.5477477477477477 0.28051001821493626)))
	 :END:
 #+BEGIN_QUOTE
 legacy technology that possesses certain archaic characteristics. For example, it restricts the body (not
 just the headers) of all mail messages to simple 7-bit ASCII.
 #+END_QUOTE
**** More legacy characteristics
	 :PROPERTIES:
	 :NOTER_PAGE: 151
	 :HIGHLIGHT: #s(pdf-highlight 151 ((0.07807807807807808 0.8069216757741348 0.4402402402402402 0.8561020036429873)))
	 :END:
 #+BEGIN_QUOTE
 It is important to observe that SMTP does not normally use intermediate mail servers for sending mail,
 even when the two mail servers are located at opposite ends of the world. If Alice’s server is in Hong
 Kong and Bob’s server is in St. Louis, the TCP
 connection is a direct connection between the Hong Kong and St. Louis servers. In particular, if Bob’s
 mail server is down, the message remains in Alice’s mail server and waits for a new attempt—the
 message does not get placed in some intermediate mail server.
 #+END_QUOTE
**** Figure 2.15 Alice sends a message to Bob
	 :PROPERTIES:
	 :NOTER_PAGE: 152
	 :HIGHLIGHT: #s(pdf-highlight 152 ((0.07687687687687687 0.27459016393442626 0.43723723723723723 0.2659380692167577)))
	 :END:

#+DOWNLOADED: screenshot @ 2023-10-28 12:09:03
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_12-09-03_screenshot.png]]

**** port 25 at the server SMTP
	 :PROPERTIES:
	 :NOTER_PAGE: 152
	 :HIGHLIGHT: #s(pdf-highlight 152 ((0.36396396396396397 0.49271402550091076 0.5627627627627627 0.4890710382513661)))
	 :END:
**** SMTP clients and servers introduce themselves
	 :PROPERTIES:
	 :NOTER_PAGE: 152
	 :HIGHLIGHT: #s(pdf-highlight 152 ((0.33393393393393395 0.575591985428051 0.7255255255255255 0.7067395264116576)))
	 :END:
 #+BEGIN_QUOTE
 During this SMTP handshaking phase, the SMTP client indicates the e-
 mail address of the sender (the person who generated the message) and the e-mail address of the
 recipient. Once the SMTP client and server have introduced themselves to each other, the client sends
 the message. SMTP can count on the reliable data transfer service of TCP to get the message to the
 server without errors. The client then repeats this process over the same TCP connection if it has other
 messages to send to the server; otherwise, it instructs TCP to close the connection.
 #+END_QUOTE
**** A dialogue between SMTP (S)erver and (C)lient
	 :PROPERTIES:
	 :NOTER_PAGE: 152
	 :HIGHLIGHT: #s(pdf-highlight 152 ((0.11171171171171171 0.8957194899817851 0.5891891891891892 0.9435336976320583)))
	 :END:
 #+BEGIN_QUOTE
 S: 220 hamburger.edu
 
 C: HELO crepes.fr
 
 S: 250 Hello crepes.fr, pleased to meet you
 
C: MAIL FROM: <alice@crepes.fr>
 
S: 250 alice@crepes.fr ... Sender ok
 
C: RCPT TO: <bob@hamburger.edu>
 
S: 250 bob@hamburger.edu ... Recipient ok
 
C: DATA
 
S: 354 Enter mail, end with ”.” on a line by itself
 
C: Do you like ketchup?
 
C: How about pickles?
 
C: .
 
S: 250 Message accepted for delivery
 
C: QUIT
 
S: 221 hamburger.edu closing connection
 #+END_QUOTE
**** Differences between HTTP and SMTP
	 :PROPERTIES:
	 :NOTER_PAGE: 154
	 :HIGHLIGHT: #s(pdf-highlight 154 ((0.7423423423423423 0.2659380692167577 0.49369369369369365 0.38160291438979965)))
	 :END:
 #+BEGIN_QUOTE
 First, HTTP is mainly
 a pull protocol—someone loads information on a Web server and users use HTTP to pull the
 information from the server at their convenience. In particular, the TCP connection is initiated by the
 machine that wants to receive the file. On the other hand, SMTP is primarily a push protocol—the
 sending mail server pushes the file to the receiving mail server. In particular, the TCP connection is
 initiated by the machine that wants to send the file.
 #+END_QUOTE

 #+BEGIN_QUOTE
 SMTP requires each message, including the
 body of each message, to be in 7-bit ASCII format. If the message contains characters that are not 7-bit
 ASCII (for example, French characters with accents) or contains binary data (such as an image file),
 then the message has to be encoded into 7-bit ASCII. HTTP data does not impose this restriction.
 #+END_QUOTE

 #+BEGIN_QUOTE
 HTTP encapsulates each object in its own
 HTTP response message. SMTP places all of the message’s objects into one message.
 #+END_QUOTE
**** Today, main clients are on local devices
	 :PROPERTIES:
	 :NOTER_PAGE: 155
	 :HIGHLIGHT: #s(pdf-highlight 155 ((0.5093093093093093 0.5482695810564663 0.8348348348348348 0.6320582877959927)))
	 :END:
 #+BEGIN_QUOTE
 today, mail access uses a client-server
 architecture—the typical user reads e-mail with a client that executes on the user’s end system, for
 example, on an office PC, a laptop, or a smartphone. By executing a mail client on a local PC, users
 enjoy a rich set of features, including the ability to view multimedia messages and attachments.
 #+END_QUOTE
**** Still two servers
	 :PROPERTIES:
	 :NOTER_PAGE: 156
	 :HIGHLIGHT: #s(pdf-highlight 156 ((0.15555555555555556 0.07058287795992714 0.26126126126126126 0.447632058287796)))
	 :END:
 #+BEGIN_QUOTE
 However, typically the sender’s user agent does not dialogue directly with the recipient’s mail
 server. Instead, as shown in Figure 2.16, Alice’s user agent uses SMTP to push the e-mail message
 into her mail server, then Alice’s mail server uses SMTP (as an SMTP client) to relay the e-mail
 message to Bob’s mail server. Why the two-step procedure? Primarily because without relaying through
 Alice’s mail server, Alice’s user agent doesn’t have any recourse to an unreachable destination
 mail server. By having Alice first deposit the e-mail in her own mail server, Alice’s mail server can
 repeatedly try to send the message to Bob’s mail server, say every 30 minutes, until Bob’s mail server
 becomes operational.
 #+END_QUOTE
#+DOWNLOADED: screenshot @ 2023-10-28 12:09:45
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_12-09-45_screenshot.png]]

**** Receiving mail by end user through SMTP is impossible, other protocols are involved
	 :PROPERTIES:
	 :NOTER_PAGE: 156
	 :HIGHLIGHT: #s(pdf-highlight 156 ((0.47567567567567565 0.5459927140255009 0.38618618618618616 0.680327868852459)))
	 :END:
 #+BEGIN_QUOTE
 How does a recipient like Bob, running a user agent on
 his local PC, obtain his messages, which are sitting in a mail server within Bob’s ISP? Note that Bob’s
 user agent can’t use SMTP to obtain the messages because obtaining the messages is a pull operation,
 whereas SMTP is a push protocol. The puzzle is completed by introducing a special mail access
 protocol that transfers messages from Bob’s mail server to his local PC. There are currently a number of
 popular mail access protocols, including Post Office Protocol—Version 3 (POP3), Internet Mail
 Access Protocol (IMAP), and HTTP.
 #+END_QUOTE
**** POP3, mail access protocol, on port 110.
	 :PROPERTIES:
	 :NOTER_PAGE: 156
	 :HIGHLIGHT: #s(pdf-highlight 156 ((0.7315315315315315 0.930783242258652 0.7849849849849849 0.9289617486338798)))
	 :END:
**** POP3 progresses through three phases: authorization, transaction, and update.
	 :PROPERTIES:
	 :NOTER_PAGE: 157
	 :HIGHLIGHT: #s(pdf-highlight 157 ((0.2744744744744745 0.05145719489981785 0.9147147147147147 0.04781420765027322)))
	 :END:
**** Replies to POP3 transactions
	 :PROPERTIES:
	 :NOTER_PAGE: 157
	 :HIGHLIGHT: #s(pdf-highlight 157 ((0.07387387387387387 0.2103825136612022 0.5495495495495495 0.2946265938069217)))
	 :END:
 #+BEGIN_QUOTE
 In a POP3 transaction, the user agent issues commands, and the server responds to each command
 with a reply. There are two possible responses: +OK (sometimes followed by server-to-client data),
 used by the server to indicate that the previous command was fine; and -ERR , used by the server to
 indicate that something was wrong with the previous command.
 #+END_QUOTE
**** Download and delete
	 :PROPERTIES:
	 :NOTER_PAGE: 157
	 :HIGHLIGHT: #s(pdf-highlight 157 ((0.7807807807807807 0.7290528233151184 0.7219219219219218 0.7572859744990893)))
	 :END:
 #+BEGIN_QUOTE
 In the download-
 and-delete mode, the user agent will issue the list , retr , and dele commands.
 #+END_QUOTE
**** Limitation of POP3
	 :PROPERTIES:
	 :NOTER_PAGE: 159
	 :HIGHLIGHT: #s(pdf-highlight 159 ((0.7663663663663663 0.075591985428051 0.40840840840840836 0.16985428051001822)))
	 :END:
 #+BEGIN_QUOTE
 this paradigm—
 namely, folders and messages in the local machine—poses a problem for the nomadic user, who would
 prefer to maintain a folder hierarchy on a remote server that can be accessed from any computer. This
 is not possible with POP3—the POP3 protocol does not provide any means for a user to create remote
 folders and assign messages to folders.
 #+END_QUOTE
**** IMAP, native mail boxes
	 :PROPERTIES:
	 :NOTER_PAGE: 159
	 :HIGHLIGHT: #s(pdf-highlight 159 ((0.07447447447447447 0.2996357012750455 0.6402402402402402 0.3442622950819672)))
	 :END:
 #+BEGIN_QUOTE
 An IMAP server will associate each message with a folder; when a message first arrives at the server, it
 is associated with the recipient’s INBOX folder. The recipient can then move the message into a new,
 user-created folder, read the message, delete the message, and so on.
 #+END_QUOTE
**** an IMAP server maintains user state information across IMAP sessions
	 :PROPERTIES:
	 :NOTER_PAGE: 159
	 :HIGHLIGHT: #s(pdf-highlight 159 ((0.2732732732732733 0.41120218579234974 0.7549549549549549 0.412568306010929)))
	 :END:
**** Web-based email, http
	 :PROPERTIES:
	 :NOTER_PAGE: 159
	 :HIGHLIGHT: #s(pdf-highlight 159 ((0.6894894894894894 0.8702185792349727 0.6492492492492492 0.7240437158469946)))
	 :END:
 #+BEGIN_QUOTE
 With this service, the user agent is
 an ordinary Web browser, and the user communicates with its remote mailbox via HTTP. When a
 recipient, such as Bob, wants to access a message in his mailbox, the e-mail message is sent from
 Bob’s mail server to Bob’s browser using the HTTP protocol rather than the POP3 or IMAP protocol.
 When a sender, such as Alice, wants to send an e-mail message, the e-mail message is sent from her
 browser to her mail server over HTTP rather than over SMTP. Alice’s mail server, however, still sends
 messages to, and receives messages from, other mail servers using SMTP.
 #+END_QUOTE
*** 2.4 DNS—The Internet’s Directory Service
    :PROPERTIES:
    :NOTER_PAGE: 160
    :END:
**** DNS
	 :PROPERTIES:
	 :NOTER_PAGE: 160
	 :HIGHLIGHT: #s(pdf-highlight 160 ((0.3963963963963964 0.9139344262295082 0.8756756756756756 0.9430783242258652)))
	 :END:
 #+BEGIN_QUOTE
 This is the main task of the Internet’s domain name system
 (DNS). The DNS is (1) a distributed database implemented in a hierarchy of DNS servers, and (2) an
 application-layer protocol that allows hosts to query the distributed database. The DNS servers are often
 UNIX machines running the Berkeley Internet Name Domain (BIND) software [BIND 2016]. The DNS
 protocol runs over UDP and uses port 53.
 #+END_QUOTE
**** DNS client and server procedures
	 :PROPERTIES:
	 :NOTER_PAGE: 161
	 :HIGHLIGHT: #s(pdf-highlight 161 ((0.1087087087087087 0.3055555555555556 0.6216216216216216 0.44626593806921677)))
	 :END:
	 1. The same user machine runs the client side of the DNS application.
	 2. The browser extracts the hostname, www.someschool.edu , from the URL and passes the
	 hostname to the client side of the DNS application.
	 3. The DNS client sends a query containing the hostname to a DNS server.
	 4. The DNS client eventually receives a reply, which includes the IP address for the hostname.
	 5. Once the browser receives the IP address from DNS, it can initiate a TCP connection to the
 HTTP server process located at port 80 at that IP address.
**** Why DNS is an application-layer protocol
	 :PROPERTIES:
	 :NOTER_PAGE: 162
	 :HIGHLIGHT: #s(pdf-highlight 162 ((0.11771771771771772 0.49408014571949 0.212012012012012 0.5564663023679417)))
	 :END:
	 1) runs between communicating end systems using the client-server paradigm 
	 2) relies on an underlying end-to-end transport protocol to transfer DNS messages between communicating end systems.
**** DNS server classes
	 :PROPERTIES:
	 :NOTER_PAGE: 163
	 :HIGHLIGHT: #s(pdf-highlight 163 ((0.5111111111111111 0.8902550091074681 0.8972972972972972 0.9348816029143898)))
	 :END:
 #+BEGIN_QUOTE
 No single DNS server has all of the mappings for
 all of the hosts in the Internet. Instead, the mappings are distributed across the DNS servers. To a first
 approximation, there are three classes of DNS servers—root DNS servers, top-level domain (TLD) DNS
 servers, and authoritative DNS servers—organized in a hierarchy as shown in Figure 2.17.
 #+END_QUOTE
#+DOWNLOADED: screenshot @ 2023-10-28 12:10:14
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_12-10-14_screenshot.png]]

**** Root name servers provide the IP addresses of the TLD servers.
	 :PROPERTIES:
	 :NOTER_PAGE: 164
	 :HIGHLIGHT: #s(pdf-highlight 164 ((0.3111111111111111 0.674408014571949 0.8306306306306306 0.6775956284153005)))
	 :END:
**** Authoritative DNS servers
	 :PROPERTIES:
	 :NOTER_PAGE: 165
	 :HIGHLIGHT: #s(pdf-highlight 165 ((0.6546546546546547 0.5742258652094717 0.35735735735735735 0.43897996357012753)))
	 :END:
 #+BEGIN_QUOTE
 Every organization with publicly accessible hosts (such as Web servers
 and mail servers) on the Internet must provide publicly accessible DNS records that map the names
 of those hosts to IP addresses. An organization’s authoritative DNS server houses these DNS
 records. An organization can choose to implement its own authoritative DNS server to hold these
 records; alternatively, the organization can pay to have these records stored in an authoritative DNS
 server of some service provider. Most universities and large companies implement and maintain
 their own primary and secondary (backup) authoritative DNS server.
 #+END_QUOTE
**** Local DNS server
	 :PROPERTIES:
	 :NOTER_PAGE: 165
	 :HIGHLIGHT: #s(pdf-highlight 165 ((0.7999999999999999 0.6420765027322405 0.3219219219219219 0.7071948998178507)))
	 :END:
 #+BEGIN_QUOTE
 A local DNS
 server does not strictly belong to the hierarchy of servers but is nevertheless central to the DNS
 architecture. Each ISP—such as a residential ISP or an institutional ISP—has a local DNS server (also
 called a default name server).
 #+END_QUOTE
**** Iterative and recursive DNS queries
	 :PROPERTIES:
	 :NOTER_PAGE: 167
	 :HIGHLIGHT: #s(pdf-highlight 167 ((0.5363363363363363 0.39025500910746813 0.9231231231231231 0.42395264116575593)))
	 :END:
 #+BEGIN_QUOTE
 In theory, any DNS query can be iterative or
 recursive. For example, Figure 2.20 shows a DNS query chain for which all of the queries are recursive.
 #+END_QUOTE

#+DOWNLOADED: screenshot @ 2023-10-28 12:10:37
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_12-10-37_screenshot.png]]

**** IP and hostname mappings are not permanent
	 :PROPERTIES:
	 :NOTER_PAGE: 168
	 :HIGHLIGHT: #s(pdf-highlight 168 ((0.45225225225225224 0.7745901639344263 0.26786786786786787 0.8356102003642987)))
	 :END:
 #+BEGIN_QUOTE
 Because hosts and mappings between hostnames and IP
 addresses are by no means permanent, DNS servers discard cached information after a period of time
 (often set to two days).
 #+END_QUOTE
**** Queries to root servers are limited
	 :PROPERTIES:
	 :NOTER_PAGE: 169
	 :HIGHLIGHT: #s(pdf-highlight 169 ((0.502102102102102 0.052823315118397086 0.19039039039039038 0.12295081967213115)))
	 :END:
 #+BEGIN_QUOTE
 A local DNS server can also cache the IP
 addresses of TLD servers, thereby allowing the local DNS server to bypass the root DNS servers in a
 query chain. In fact, because of caching, root servers are bypassed for all but a very small fraction of
 DNS queries.
 #+END_QUOTE
**** Database of DNS servers
	 :PROPERTIES:
	 :NOTER_PAGE: 169
	 :HIGHLIGHT: #s(pdf-highlight 169 ((0.7087087087087087 0.24225865209471767 0.5531531531531532 0.2659380692167577)))
	 :END:
 #+BEGIN_QUOTE
 resource records (RRs),
 including RRs that provide hostname-to-IP address mappings.
 #+END_QUOTE
**** resource record field is a four-tuple
	 :PROPERTIES:
	 :NOTER_PAGE: 169
	 :HIGHLIGHT: #s(pdf-highlight 169 ((0.1135135135135135 0.43897996357012753 0.4072072072072072 0.44489981785063754)))
	 :END:
 ``(Name, Value, Type, TTL)''
**** Types of records
	 :PROPERTIES:
	 :NOTER_PAGE: 169
	 :HIGHLIGHT: #s(pdf-highlight 169 ((0.0984984984984985 0.5906193078324226 0.854054054054054 0.9221311475409836)))
	 :END:
	 1) If Type=A , then Name is a hostname and Value is the IP address for the hostname. Thus, a Type A record provides the standard hostname-to-IP address mapping. As an example, (relay1.bar.foo.com, 145.37.93.126, A) is a Type A record.
	 2) If Type=NS , then Name is a domain (such as foo.com ) and Value is the hostname of an authoritative DNS server that knows how to obtain the IP addresses for hosts in the domain. This record is used to route DNS queries further along in the query chain. As an example, (foo.com, dns.foo.com, NS) is a Type NS record.
	 3) If Type=CNAME , then Value is a canonical hostname for the alias hostname Name . This record can provide querying hosts the canonical name for a hostname. As an example, (foo.com, relay1.bar.foo.com, CNAME) is a CNAME record.
	 4) If Type=MX , then Value is the canonical name of a mail server that has an alias hostname Name. As an example, (foo.com, mail.bar.foo.com, MX) is an MX record. MX records allow the hostnames of mail servers to have simple aliases. Note that by using the MX record, a company can have the same aliased name for its mail server and for one of its other servers (such as its Web server). 
**** Figure 2.21 DNS message format
	 :PROPERTIES:
	 :NOTER_PAGE: 171
	 :HIGHLIGHT: #s(pdf-highlight 171 ((0.4028223220012829 0.05350194552529183 0.12892880051314945 0.05350194552529183)))
	 :END:

#+DOWNLOADED: screenshot @ 2023-10-28 12:11:27
[[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_12-11-27_screenshot.png]]

**** nslookup program
	 :PROPERTIES:
	 :NOTER_PAGE: 171
	 :HIGHLIGHT: #s(pdf-highlight 171 ((0.08851828094932648 0.5676070038910506 0.6125721616420782 0.5875486381322957)))
	 :END:
 #+BEGIN_QUOTE
 How would you like to send a DNS query message directly from the host you’re working on to some
 DNS server? This can easily be done with the nslookup program,
 #+END_QUOTE
**** Registrar
	 :PROPERTIES:
	 :NOTER_PAGE: 172
	 :HIGHLIGHT: #s(pdf-highlight 172 ((0.3919178960872354 0.05787937743190662 0.32135984605516354 0.09143968871595332)))
	 :END:
 #+BEGIN_QUOTE
 A registrar is a commercial entity that verifies the uniqueness of
 the domain name, enters the domain name into the DNS database (as discussed below), and collects a
 small fee from you for its services.
 #+END_QUOTE
**** Example of registrar inserting resource records into DNS system
	 :PROPERTIES:
	 :NOTER_PAGE: 172
	 :HIGHLIGHT: #s(pdf-highlight 172 ((0.11729857819905214 0.4716981132075472 0.6007109004739337 0.5080862533692723)))
	 :END:
 #+BEGIN_QUOTE
 (networkutopia.com, dns1.networkutopia.com, NS)
 (dns1.networkutopia.com, 212.212.212.1, A)
 #+END_QUOTE
**** DNS's immunity to attacks
	 :PROPERTIES:
	 :NOTER_PAGE: 173
	 :HIGHLIGHT: #s(pdf-highlight 173 ((0.2185185185185185 0.4898876404494382 0.697037037037037 0.5140449438202248)))
	 :END:
 #+BEGIN_QUOTE
 DNS has demonstrated itself to be surprisingly robust against attacks. To date,
 there hasn’t been an attack that has successfully impeded the DNS service.
 #+END_QUOTE
**** DNS additional services
	 - Host aliasing
	 - Mail server aliasing
	 - Load distribution
*** 2.5 Peer-to-Peer File Distribution
    :PROPERTIES:
    :NOTER_PAGE: 175
    :END:
**** File distribution time for client-server architecture
	 :PROPERTIES:
	 :NOTER_PAGE: 176
	 :HIGHLIGHT: #s(pdf-highlight 176 ((0.0748148148148148 0.6455056179775281 0.3125925925925926 0.9359550561797754)))
	 :END:
 #+BEGIN_QUOTE
 Let’s first determine the distribution time for the client-server architecture, which we denote by Dcs. In the
 client-server architecture, none of the peers aids in distributing the file. We make the following
 observations:
 The server must transmit one copy of the file to each of the N peers. Thus the server must transmit
 NF bits. Since the server’s upload rate is us, the time to distribute the file must be at least NF/us.
 Let dmin denote the download rate of the peer with the lowest download rate, that is,
 dmin=min{d1,dp,. . .,dN}. The peer with the lowest download rate cannot obtain all F bits of the file in
 less than F/dmin seconds. Thus the minimum distribution time is at least F/dmin.
 Putting these two observations together, we obtain
 Dcs≥max{NFus,Fdmin}.
 #+END_QUOTE
**** File distribution time for peer-to-peer architecture
	 :PROPERTIES:
	 :NOTER_PAGE: 177
	 :HIGHLIGHT: #s(pdf-highlight 177 ((0.06939281288723669 0.5023496240601504 0.41263940520446096 0.8571428571428571)))
	 :END:
 #+BEGIN_QUOTE
 At the beginning of the distribution, only the server has the file. To get this file into the community of
 peers, the server must send each bit of the file at least once into its access link. Thus, the minimum
 distribution time is at least F/us. (Unlike the client-server scheme, a bit sent once by the server may
 not have to be sent by the server again, as the peers may redistribute the bit among themselves.)
 As with the client-server architecture, the peer with the lowest download rate cannot obtain all F bits
 of the file in less than F/dmin seconds. Thus the minimum distribution time is at least F/dmin.
 Finally, observe that the total upload capacity of the system as a whole is equal to the upload rate of
 the server plus the upload rates of each of the individual peers, that is, utotal=us+u1+⋯+uN. The
 system must deliver (upload) F bits to each of the N peers, thus delivering a total of NF bits. This
 cannot be done at a rate faster than utotal. Thus, the minimum distribution time is also at least
 NF/(us+u1+⋯+uN).
 Putting these three observations together, we obtain the minimum distribution time for P2P, denoted by
 DP2P.
 DP2P≥max{Fus,Fdmin,NFus+∑i=1Nui}
 #+END_QUOTE
**** torrent
	 :PROPERTIES:
	 :NOTER_PAGE: 179
	 :HIGHLIGHT: #s(pdf-highlight 179 ((0.6864931846344485 0.06203007518796992 0.09107806691449814 0.05592105263157894)))
	 :END:
 #+BEGIN_QUOTE
 the collection of all peers participating in the distribution of a particular file is called a torrent.
 #+END_QUOTE
**** chunk
	 :PROPERTIES:
	 :NOTER_PAGE: 179
	 :HIGHLIGHT: #s(pdf-highlight 179 ((0.6939281288723668 0.06109022556390977 0.7453531598513011 0.08176691729323307)))
	 :END:
 #+BEGIN_QUOTE
 Peers in a torrent download
 equal-size chunks of the file from one another, with a typical chunk size of 256 KBytes.
 #+END_QUOTE
**** Each torrent has an infrastructure node called a tracker.
	 :PROPERTIES:
	 :NOTER_PAGE: 179
	 :HIGHLIGHT: #s(pdf-highlight 179 ((0.6146220570012392 0.28430451127819545 0.25960346964064435 0.31109022556390975)))
	 :END:
**** Rarest first technique
	 :PROPERTIES:
	 :NOTER_PAGE: 180
	 :HIGHLIGHT: #s(pdf-highlight 180 ((0.08736059479553904 0.47791353383458646 0.8110285006195787 0.5460526315789473)))
	 :END:
 #+BEGIN_QUOTE
 The idea is to determine, from among the chunks she does not have, the chunks that are the rarest
 among her neighbors (that is, the chunks that have the fewest repeated copies among her neighbors)
 and then request those rarest chunks first. In this manner, the rarest chunks get more quickly
 redistributed, aiming to (roughly) equalize the numbers of copies of each chunk in the torrent.
 #+END_QUOTE
**** Unchoked - active
	 :PROPERTIES:
	 :NOTER_PAGE: 180
	 :HIGHLIGHT: #s(pdf-highlight 180 ((0.4188351920693928 0.6790413533834586 0.8116480793060719 0.7015977443609022)))
	 :END:
 #+BEGIN_QUOTE
 Every 10 seconds, she recalculates the rates and possibly
 modifies the set of four peers. In BitTorrent lingo, these four peers are said to be unchoked.
 #+END_QUOTE
**** Top partners
	 :PROPERTIES:
	 :NOTER_PAGE: 180
	 :HIGHLIGHT: #s(pdf-highlight 180 ((0.4083023543990087 0.9069548872180451 0.7242874845105328 0.8359962406015037)))
	 :END:
 #+BEGIN_QUOTE
 If the two peers are
 satisfied with the trading, they will put each other in their top four lists and continue trading with each
 other until one of the peers finds a better partner. The effect is that peers capable of uploading at
 compatible rates tend to find each other.
 #+END_QUOTE
**** tit-for-tat, unmerciful trading
	 :PROPERTIES:
	 :NOTER_PAGE: 181
	 :HIGHLIGHT: #s(pdf-highlight 181 ((0.46964064436183395 0.25798872180451127 0.8649318463444857 0.14332706766917291)))
	 :END:
 #+BEGIN_QUOTE
 It has
 been shown that this incentive scheme can be circumvented [Liogkas 2006; Locher 2006; Piatek
 2007]. Nevertheless, the BitTorrent ecosystem is wildly successful, with millions of simultaneous peers
 actively sharing files in hundreds of thousands of torrents. If BitTorrent had been designed without tit-for-
 tat (or a variant), but otherwise exactly the same, BitTorrent would likely not even exist now, as the
 majority of the users would have been freeriders
 #+END_QUOTE
**** distributed hash table
	 :PROPERTIES:
	 :NOTER_PAGE: 181
	 :HIGHLIGHT: #s(pdf-highlight 181 ((0.24101610904584883 0.32612781954887216 0.419454770755886 0.34962406015037595)))
	 :END:
 #+BEGIN_QUOTE
 A distributed hash table is a simple database, with the database records being
 distributed over the peers in a P2P system.
 #+END_QUOTE
*** 2.6 Video Streaming and Content Distribution Networks
    :PROPERTIES:
    :NOTER_PAGE: 182
    :END:
**** end-to-end throughput
	 :PROPERTIES:
	 :NOTER_PAGE: 182
	 :HIGHLIGHT: #s(pdf-highlight 182 ((0.7850061957868649 0.8660714285714285 0.6858736059479554 0.9412593984962405)))
	 :END:
 #+BEGIN_QUOTE
 By far, the most
 important performance measure for streaming video is average end-to-end throughput. In order to
 provide continuous playout, the network must provide an average throughput to the streaming
 application that is at least as large as the bit rate of the compressed video.
 #+END_QUOTE
**** HTTP streaming
	 :PROPERTIES:
	 :NOTER_PAGE: 183
	 :HIGHLIGHT: #s(pdf-highlight 183 ((0.0868804664723032 0.2745358090185676 0.7597667638483965 0.34880636604774534)))
	 :END:
 #+BEGIN_QUOTE
 In HTTP streaming, the video is simply stored at an HTTP server as an ordinary file with a specific URL.
 When a user wants to see the video, the client establishes a TCP connection with the server and issues
 an HTTP GET request for that URL. The server then sends the video file...
 the streaming
 video application periodically grabs video frames from the client application buffer, decompresses the
 frames, and displays them on the user’s screen.
 #+END_QUOTE
**** DASH
	 :PROPERTIES:
	 :NOTER_PAGE: 183
	 :HIGHLIGHT: #s(pdf-highlight 183 ((0.4209912536443149 0.6640141467727674 0.5504373177842565 0.6025641025641025)))
	 :END:
 #+BEGIN_QUOTE
 Dynamic Adaptive Streaming over HTTP
 (DASH). In DASH, the video is encoded into several different versions, with each version having a
 different bit rate and, correspondingly, a different quality level. The client dynamically requests chunks of
 video segments of a few seconds in length.
 #+END_QUOTE
**** Manifest file
	 :PROPERTIES:
	 :NOTER_PAGE: 184
	 :HIGHLIGHT: #s(pdf-highlight 184 ((0.07230320699708455 0.04288240495137047 0.6239067055393586 0.07382847038019451)))
	 :END:
 #+BEGIN_QUOTE
 The HTTP server also has a manifest file, which provides a URL for each version along with its bit rate. The client
 first requests the manifest file and learns about the various versions.
 #+END_QUOTE
**** Problems of streaming from one big data center
	 :PROPERTIES:
	 :NOTER_PAGE: 184
	 :HIGHLIGHT: #s(pdf-highlight 184 ((0.23556851311953353 0.6503094606542882 0.18658892128279883 0.5587975243147657)))
	 :END:
	 - If one of communcation ISP links provides a throughput that is less than the video consumption rate, the end-to-end throughput will also be below the consumption rate, resulting in annoying freezing delays for the user.
	 - Popular video will likely be sent many times over the same communication links.
	 - With this solution is that a single data center represents a single point of failure
**** CDNs
	 :PROPERTIES:
	 :NOTER_PAGE: 184
	 :HIGHLIGHT: #s(pdf-highlight 184 ((0.6303206997084548 0.8731211317418214 0.8431486880466472 0.9345711759504862)))
	 :END:
 #+BEGIN_QUOTE
 Content Distribution Networks
 (CDNs). A CDN manages servers in multiple geographically distributed locations, stores copies of the
 videos (and other types of Web content, including documents, images, and audio) in its servers, and
 attempts to direct each user request to a CDN location that will provide the best user experience.
 #+END_QUOTE
**** Private and third-party CDNs
	 :PROPERTIES:
	 :NOTER_PAGE: 185
	 :HIGHLIGHT: #s(pdf-highlight 185 ((0.08629737609329446 0.05305039787798408 0.6034985422740524 0.09725906277630415)))
	 :END:
 #+BEGIN_QUOTE
 CDN may be a private CDN, that is, owned by the content provider itself; for example, Google’s CDN
 distributes YouTube videos and other types of content. The CDN may alternatively be a third-party
 CDN that distributes content on behalf of multiple content providers;
 #+END_QUOTE
**** CDN server placement philosophies
	 :PROPERTIES:
	 :NOTER_PAGE: 185
	 :HIGHLIGHT: #s(pdf-highlight 185 ((0.11137026239067055 0.20822281167108753 0.8046647230320699 0.23474801061007958)))
	 :END:
 #+BEGIN_QUOTE
 Enter Deep. One philosophy, pioneered by Akamai, is to enter deep into the access networks of
 Internet Service Providers, by deploying server clusters in access ISPs all over the world.
 #+END_QUOTE

 #+BEGIN_QUOTE
 bring the ISPs home by building large clusters at a smaller number (for example, tens) of sites.
 Instead of getting inside the access ISPs, these CDNs typically place their clusters in Internet
 Exchange Points (IXPs)
 #+END_QUOTE
**** CDN must intercept the request so that it can
	 :PROPERTIES:
	 :NOTER_PAGE: 186
	 :HIGHLIGHT: #s(pdf-highlight 186 ((0.6443148688046647 0.5875331564986737 0.39825072886297375 0.6396993810786914)))
	 :END:
	 1) determine a suitable CDN server cluster for that client at that time, 
	 2) redirect the client’s request to a server in that cluster.
**** When CDN server is found
	 :PROPERTIES:
	 :NOTER_PAGE: 187
	 :HIGHLIGHT: #s(pdf-highlight 187 ((0.11895043731778425 0.7320954907161803 0.2075801749271137 0.8156498673740052)))
	 :END:
 #+BEGIN_QUOTE
 6. Once the client receives the IP address for a KingCDN content server, it establishes a direct
 TCP connection with the server at that IP address and issues an HTTP GET request for the
 video. If DASH is used, the server will first send to the client a manifest file with a list of URLs,
 one for each version of the video, and the client will dynamically select chunks from the different
 versions.
 #+END_QUOTE
**** Figure 2.25 DNS redirects a user’s request to a CDN server
	 :PROPERTIES:
	 :NOTER_PAGE: 187
	 :HIGHLIGHT: #s(pdf-highlight 187 ((0.14752186588921282 0.6427939876215738 0.6256559766763848 0.6556145004420866)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-10-28 12:52:40
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_12-52-40_screenshot.png]]
**** CDNs employ proprietary cluster selection strategies.
	 :PROPERTIES:
	 :NOTER_PAGE: 188
	 :HIGHLIGHT: #s(pdf-highlight 188 ((0.7486880466472303 0.07692307692307691 0.4425655976676385 0.10212201591511935)))
	 :END:
	 - Assign the client to the cluster that is geographically closest.
 #+BEGIN_QUOTE
 the solution may perform poorly, since
 the geographically closest cluster may not be the closest cluster in terms of the length or number of
 hops of the network path.
 #+END_QUOTE

 #+BEGIN_QUOTE
 ignores the variation
 in delay and available bandwidth over time of Internet paths, always assigning the same cluster to a
 particular client.
 #+END_QUOTE
	 - Perform periodic real-time measurements of delay and loss performance between their clusters and clients.
 #+BEGIN_QUOTE
 periodically send probes (for
 example, ping messages or DNS queries) to all of the LDNSs around the world. One drawback of this
 approach is that many LDNSs are configured to not respond to such probes.
 #+END_QUOTE
**** Netflix example
	 :PROPERTIES:
	 :NOTER_PAGE: 189
	 :HIGHLIGHT: #s(pdf-highlight 189 ((0.09504373177842565 0.12157382847038019 0.517201166180758 0.30813439434129086)))
	 :END:
	 - Content ingestion. Before Netflix can distribute a movie to its customers, it must first ingest and process the movie. Netflix receives studio master versions of movies and uploads them to hosts in the Amazon cloud.
	 - Content processing. The machines in the Amazon cloud create many different formats for each movie, suitable for a diverse array of client video players running on desktop computers, smartphones, and game consoles connected to televisions. A different version is created for each of these formats and at multiple bit rates, allowing for adaptive streaming over HTTP using DASH.
	 - Uploading versions to its CDN. Once all of the versions of a movie have been created, the hosts in the Amazon cloud upload the versions to its CDN.

 #+DOWNLOADED: screenshot @ 2023-10-28 13:02:45
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_13-02-45_screenshot.png]]
**** Netflix video distribution strategy
	 :PROPERTIES:
	 :NOTER_PAGE: 190
	 :HIGHLIGHT: #s(pdf-highlight 190 ((0.5037900874635568 0.1865605658709107 0.2956268221574344 0.1295313881520778)))
	 :END:
 #+BEGIN_QUOTE
 Netflix does not use pull-caching (Section 2.2.5) to populate its CDN servers
 in the IXPs and ISPs. Instead, Netflix distributes by pushing the videos to its CDN servers during off-
 peak hours. For those locations that cannot hold the entire library, Netflix pushes only the most popular
 videos, which are determined on a day-to-day basis.
 #+END_QUOTE
**** YouTube does not use DASH
	 :PROPERTIES:
	 :NOTER_PAGE: 191
	 :HIGHLIGHT: #s(pdf-highlight 191 ((0.6174927113702624 0.34659593280282935 0.7597667638483965 0.37179487179487175)))
	 :END:
 #+BEGIN_QUOTE
 YouTube does not employ adaptive
 streaming (such as DASH), but instead requires the user to manually select a version.
 #+END_QUOTE
*** 2.7 Socket Programming: Creating Network Applications
    :PROPERTIES:
    :NOTER_PAGE: 193
    :END:
**** UDP
***** Sending process
	  :PROPERTIES:
	  :NOTER_PAGE: 195
	  :HIGHLIGHT: #s(pdf-highlight 195 ((0.1924198250728863 0.1958443854995579 0.6174927113702624 0.21706454465075153)))
	  :END:
  #+BEGIN_QUOTE
  the sending process attaches to the packet a destination address, which consists of the
  destination host’s IP address and the destination socket’s port number.
  sender’s source address—consisting of the IP address of the source host and the port number of the
  source socket—are also attached to the packet. However, attaching the source address to the packet is
  typically not done by the UDP application code; instead it is automatically done by the underlying
  operating system.
  #+END_QUOTE
***** When a socket is created, an identifier, called a port number, is assigned

***** UDPClient.py
	  :PROPERTIES:
	  :NOTER_PAGE: 196
	  :HIGHLIGHT: #s(pdf-highlight 196 ((0.08221574344023323 0.773209549071618 0.16909620991253643 0.7763041556145004)))
	  :END:
  #+BEGIN_QUOTE
  from socket import *

  serverName = ’hostname’

  serverPort = 12000

  clientSocket = socket(AF_INET, SOCK_DGRAM)

  message = raw_input(’Input lowercase sentence:’)

  clientSocket.sendto(message.encode(),(serverName, serverPort))

  modifiedMessage, serverAddress = clientSocket.recvfrom(2048)

  print(modifiedMessage.decode())

  clientSocket.close()
  #+END_QUOTE
	  - AF_INET indicates that the underlying network is using IPv4.
	  - SOCK_DGRAM , which means it is a UDP socket
  #+BEGIN_QUOTE
  Note that we are not
  specifying the port number of the client socket when we create it; we are instead letting the operating
  system do this for us.
  #+END_QUOTE

  #+BEGIN_QUOTE
  first convert the message from string type to byte type, as we need to send bytes
  into a socket; this is done with the encode() method.
  #+END_QUOTE

  #+BEGIN_QUOTE
  The method recvfrom also takes the buffer size 2048 as input. (This buffer size
  works for most purposes.)
  #+END_QUOTE

***** Figure 2.27 The client-server application using UDP
	  :PROPERTIES:
	  :NOTER_PAGE: 196
	  :HIGHLIGHT: #s(pdf-highlight 196 ((0.07055393586005831 0.5366931918656056 0.5620991253644315 0.5358090185676392)))
	  :END:

  #+DOWNLOADED: screenshot @ 2023-10-28 13:39:26
  [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_13-39-26_screenshot.png]]

***** UDPServer.py
	  :PROPERTIES:
	  :NOTER_PAGE: 199
	  :HIGHLIGHT: #s(pdf-highlight 199 ((0.08746355685131195 0.09549071618037135 0.18833819241982508 0.09946949602122016)))
	  :END:
  #+BEGIN_QUOTE
  from socket import *
  serverPort = 12000
  serverSocket = socket(AF_INET, SOCK_DGRAM)
  serverSocket.bind((’’, serverPort))
  print(”The server is ready to receive”)
  while True:
  message, clientAddress = serverSocket.recvfrom(2048)
  modifiedMessage = message.decode().upper()
  serverSocket.sendto(modifiedMessage.encode(), clientAddress)
  #+END_QUOTE

  #+BEGIN_QUOTE
  The first line of code that is significantly different from UDPClient is:
  serverSocket.bind((’’, serverPort))
  #+END_QUOTE

**** TCP
***** welcoming socket
	  :PROPERTIES:
	  :NOTER_PAGE: 201
	  :HIGHLIGHT: #s(pdf-highlight 201 ((0.5154518950437318 0.36870026525198935 0.4198250728862974 0.43987621573828467)))
	  :END:
  #+BEGIN_QUOTE
  When the client creates its TCP socket, it specifies
  the address of the welcoming socket in the server, namely, the IP address of the server host and the
  port number of the socket. After creating its socket, the client initiates a three-way handshake and
  establishes a TCP connection with the server.
  #+END_QUOTE

***** Dedicated socket
	  :PROPERTIES:
	  :NOTER_PAGE: 201
	  :HIGHLIGHT: #s(pdf-highlight 201 ((0.1597667638483965 0.5234305923961096 0.39999999999999997 0.5517241379310345)))
	  :END:
  #+BEGIN_QUOTE
  When the server “hears” the knocking, it creates a new door—more precisely, a new socket
  that is dedicated to that particular ­client.
  #+END_QUOTE

***** Figure 2.28 The TCPServer process has two sockets
	  :PROPERTIES:
	  :NOTER_PAGE: 202
	  :HIGHLIGHT: #s(pdf-highlight 202 ((0.08221574344023323 0.4588859416445623 0.5568513119533528 0.4513704686118479)))
	  :END:

  #+DOWNLOADED: screenshot @ 2023-10-28 13:37:40
  [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_13-37-40_screenshot.png]]

***** Figure 2.29 The client-server application using TCP
	  :PROPERTIES:
	  :NOTER_PAGE: 203
	  :HIGHLIGHT: #s(pdf-highlight 203 ((0.08571428571428572 0.7798408488063661 0.5329446064139942 0.77763041556145)))
	  :END:

  #+DOWNLOADED: screenshot @ 2023-10-28 13:40:04
  [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_13-40-04_screenshot.png]]

***** TCPClient.py
	  :PROPERTIES:
	  :NOTER_PAGE: 202
	  :HIGHLIGHT: #s(pdf-highlight 202 ((0.08746355685131195 0.5167992926613616 0.21574344023323616 0.5216622458001768)))
	  :END:
  #+BEGIN_QUOTE
  from socket import *

  serverName = ’servername’

  serverPort = 12000

  clientSocket = socket(AF_INET, SOCK_STREAM)

  clientSocket.connect((serverName, serverPort))

  sentence = raw_input(’Input lowercase sentence:’)

  clientSocket.send(sentence.encode())

  modifiedSentence = clientSocket.recv(1024)

  print(’From Server: ’, modifiedSentence.decode())

  clientSocket.close()
  #+END_QUOTE

***** Lines different from UDP
	  :PROPERTIES:
	  :NOTER_PAGE: 204
	  :HIGHLIGHT: #s(pdf-highlight 204 ((0.12011661807580175 0.07824933687002653 0.6256559766763848 0.09416445623342175)))
	  :END:
  #+BEGIN_QUOTE
  SOCK_STREAM , which means it is a TCP socket

  clientSocket.connect((serverName, serverPort))

  The parameter of the connect() method is the address of
  the server side of the connection. After this line of code is executed, the three-way handshake is
  performed and a TCP connection is established between the client and server.

  clientSocket.send(sentence.encode())

  The above line sends the sentence through the client’s socket and into the TCP connection. Note that
  the program does not explicitly create a packet and attach the destination address to the packet, as was
  the case with UDP sockets. Instead the client program simply drops the bytes in the string sentence
  into the TCP connection.
  #+END_QUOTE

***** TCPServer.py
	  :PROPERTIES:
	  :NOTER_PAGE: 205
	  :HIGHLIGHT: #s(pdf-highlight 205 ((0.06763848396501458 0.05791335101679929 0.2314868804664723 0.0627763041556145)))
	  :END:
  #+BEGIN_QUOTE
  from socket import *

  serverPort = 12000

  serverSocket = socket(AF_INET, SOCK_STREAM)

  serverSocket.bind((’’, serverPort))

  serverSocket.listen(1)

  print(’The server is ready to receive’)

  while True:

      connectionSocket, addr = serverSocket.accept()
    
      sentence = connectionSocket.recv(1024).decode()
    
      capitalizedSentence = sentence.upper()
    
      connectionSocket.send(capitalizedSentence.encode())
    
      connectionSocket.close()
  #+END_QUOTE

  #+BEGIN_QUOTE
  After establishing this welcoming door, we
  will wait and listen for some client to knock on the door:

  serverSocket.listen(1)

  This line has the server listen for TCP connection requests from the client. The parameter specifies the
  maximum number of queued connections (at least 1).
  #+END_QUOTE
** Chapter 3 Transport Layer
   :PROPERTIES:
   :NOTER_PAGE: 223
   :END:
*** 3.1 Introduction and Transport-Layer Services
    :PROPERTIES:
    :NOTER_PAGE: 224
    :END:
**** Transport-layer definition
	 :PROPERTIES:
	 :NOTER_PAGE: 224
	 :HIGHLIGHT: #s(pdf-highlight 224 ((0.08569667077681874 0.24777933613838243 0.6658446362515413 0.3071528751753156)))
	 :END:
 #+BEGIN_QUOTE
 A transport-layer protocol provides for logical communication between application processes running
 on different hosts. By logical communication, we mean that from an application’s perspective, it is as if
 the hosts running the processes were directly connected; in reality, the hosts may be on opposite sides
 of the planet, connected via numerous routers and a wide range of link types.
 #+END_QUOTE
**** Routers look only at network-layer
	 :PROPERTIES:
	 :NOTER_PAGE: 224
	 :HIGHLIGHT: #s(pdf-highlight 224 ((0.1781750924784217 0.581580177653109 0.15721331689272502 0.6227208976157083)))
	 :END:
 #+BEGIN_QUOTE
 It’s important to note that network routers act only on the network-layer fields of the
 datagram; that is, they do not examine the fields of the transport-layer segment encapsulated with the
 datagram.
 #+END_QUOTE
**** Difference between network-layer and transport-layer
	 :PROPERTIES:
	 :NOTER_PAGE: 225
	 :HIGHLIGHT: #s(pdf-highlight 225 ((0.08199753390875462 0.8246844319775597 0.12638717632552404 0.8513323983169706)))
	 :END:
 #+BEGIN_QUOTE
 Whereas a transport-layer protocol provides logical communication between processes running on different hosts, a network-layer protocol provides logical-communication between
 hosts.
 #+END_QUOTE
**** UDP and TCP
	 :PROPERTIES:
	 :NOTER_PAGE: 227
	 :HIGHLIGHT: #s(pdf-highlight 227 ((0.07829839704069051 0.643291257597008 0.7700369913686806 0.6914446002805049)))
	 :END:
 #+BEGIN_QUOTE
 One of these protocols is UDP (User Datagram Protocol), which provides an unreliable, connectionless
 service to the invoking application. The second of these protocols is TCP (Transmission Control
 Protocol), which provides a reliable, connection-oriented service to the invoking application.
 #+END_QUOTE
**** we refer to the transport-layer packet as a segment.
	 :PROPERTIES:
	 :NOTER_PAGE: 227
	 :HIGHLIGHT: #s(pdf-highlight 227 ((0.27743526510480887 0.8078541374474054 0.6689272503082614 0.7994389901823282)))
	 :END:
**** IP, network protocol
	 :PROPERTIES:
	 :NOTER_PAGE: 228
	 :HIGHLIGHT: #s(pdf-highlight 228 ((0.840937114673243 0.08087891538101917 0.7256473489519112 0.19027582982702199)))
	 :END:
 #+BEGIN_QUOTE
 The
 Internet’s network-layer protocol has a name—IP, for Internet Protocol. IP provides logical
 communication between hosts. The IP service model is a best-effort delivery service. This means that
 IP makes its “best effort” to deliver segments between communicating hosts, but it makes no
 guarantees. In particular, it does not guarantee segment delivery, it does not guarantee orderly delivery
 of segments, and it does not guarantee the integrity of the data in the segments.
 #+END_QUOTE
**** Transport-layer multiplexing and demultiplexing
	 :PROPERTIES:
	 :NOTER_PAGE: 228
	 :HIGHLIGHT: #s(pdf-highlight 228 ((0.21023427866831074 0.321645628798504 0.25092478421701603 0.39878447872837774)))
	 :END:
 #+BEGIN_QUOTE
 The most fundamental responsibility of UDP and TCP is to extend IP’s delivery service
 between two end systems to a delivery service between two processes running on the end systems.
 Extending host-to-host delivery to process-to-process delivery is called transport-layer multiplexing
 and demultiplexing.
 #+END_QUOTE
*** 3.2 Multiplexing and Demultiplexing
    :PROPERTIES:
    :NOTER_PAGE: 230
    :END:
**** Demultiplexing
	 :PROPERTIES:
	 :NOTER_PAGE: 230
	 :HIGHLIGHT: #s(pdf-highlight 230 ((0.08816276202219482 0.6951846657316504 0.2638717632552404 0.7858812529219261)))
	 :END:
 #+BEGIN_QUOTE
 Now let’s consider how a receiving host directs an incoming transport-layer segment to the appropriate
 socket. Each transport-layer segment has a set of fields in the segment for this purpose. At the receiving
 end, the transport layer examines these fields to identify the receiving socket and then directs the
 segment to that socket. This job of delivering the data in a transport-layer segment to the correct socket
 is called demultiplexing.
 #+END_QUOTE
**** Multiplexing
	 :PROPERTIES:
	 :NOTER_PAGE: 230
	 :HIGHLIGHT: #s(pdf-highlight 230 ((0.2934648581997534 0.7849462365591399 0.7854500616522812 0.8345021037868163)))
	 :END:
 #+BEGIN_QUOTE
 The job of gathering data chunks at the source host from different sockets,
 encapsulating each data chunk with header information (that will later be used in demultiplexing) to
 create segments, and passing the segments to the network layer is called multiplexing.
 #+END_QUOTE
**** Figure 3.2 Transport-layer multiplexing and demultiplexing
	 :PROPERTIES:
	 :NOTER_PAGE: 231
	 :HIGHLIGHT: #s(pdf-highlight 231 ((0.093711467324291 0.35577372604020574 0.5752157829839705 0.3576437587657784)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-10-28 17:57:43
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_17-57-43_screenshot.png]]
**** Transport-layer mutliplexing requirements
	 :PROPERTIES:
	 :NOTER_PAGE: 231
	 :HIGHLIGHT: #s(pdf-highlight 231 ((0.6405672009864365 0.758765778401122 0.5456226880394575 0.8129967274427303)))
	 :END:
	 - sockets have unique identifiers (source port number field)
	 - each segment have special fields that indicate the socket to which the segment is to be delivered (destination port number field)
**** Port numbers
	 :PROPERTIES:
	 :NOTER_PAGE: 231
	 :HIGHLIGHT: #s(pdf-highlight 231 ((0.8273736128236745 0.8461898083216457 0.17755856966707767 0.916783543712015)))
	 :END:
 #+BEGIN_QUOTE
 Each port
 number is a 16-bit number, ranging from 0 to 65535. The port numbers ranging from 0 to 1023 are
 called well-known port numbers and are restricted, which means that they are reserved for use by
 well-known application protocols such as HTTP (which uses port number 80) and FTP (which uses port number 21).
 #+END_QUOTE
**** Figure 3.3 Source and destination port-number fields in a transport-layer segment
	 :PROPERTIES:
	 :NOTER_PAGE: 232
	 :HIGHLIGHT: #s(pdf-highlight 232 ((0.07151664611590629 0.25853202431042543 0.8341553637484587 0.2632071061243572)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-10-28 18:01:35
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_18-01-35_screenshot.png]]
**** Difference between a TCP socket and a UDP socket
	 :PROPERTIES:
	 :NOTER_PAGE: 233
	 :HIGHLIGHT: #s(pdf-highlight 233 ((0.2990135635018496 0.9326788218793829 0.8958076448828607 0.9219261337073399)))
	 :END:
 #+BEGIN_QUOTE
 TCP socket is identified by a four-tuple: (source IP address, source port number, destination IP address,
 destination port number). Thus, when a TCP segment arrives from the network to a host, the host uses
 all four values to direct (demultiplex) the segment to the appropriate socket.
 #+END_QUOTE
**** TCP demultiplexing
	 :PROPERTIES:
	 :NOTER_PAGE: 235
	 :HIGHLIGHT: #s(pdf-highlight 235 ((0.596177558569667 0.3796166432912576 0.5382244143033292 0.41888733052828425)))
	 :END:
 #+BEGIN_QUOTE
 When a TCP segment arrives at the
 host, all four fields (source IP address, source port, destination IP address, destination port) are used to
 direct (demultiplex) the segment to the appropriate socket.
 #+END_QUOTE
**** nmap program
	 :PROPERTIES:
	 :NOTER_PAGE: 235
	 :HIGHLIGHT: #s(pdf-highlight 235 ((0.4217016029593095 0.8546049555867228 0.1276202219482121 0.8003740065451146)))
	 :END:
 #+BEGIN_QUOTE
 Determining which applications are listening on which ports is a relatively easy task. Indeed
 there are a number of public domain programs, called port scanners, that do just that. Perhaps
 the most widely used of these is nmap.
 nmap returns a list of open, closed, or unreachable ports.
 #+END_QUOTE
**** Figure 3.5 Two clients, using the same destination port number (80) to communicate with the same Web server application
	 :PROPERTIES:
	 :NOTER_PAGE: 236
	 :HIGHLIGHT: #s(pdf-highlight 236 ((0.08261405672009864 0.5123889668069191 0.3353884093711467 0.5343618513323983)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-10-28 18:15:45
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_18-15-45_screenshot.png]]
**** Separate sockets for each client
	 :PROPERTIES:
	 :NOTER_PAGE: 237
	 :HIGHLIGHT: #s(pdf-highlight 237 ((0.8822441430332922 0.1898083216456288 0.30517879161528977 0.15194015895278168)))
	 :END:
 #+BEGIN_QUOTE
 We mention, however, that there is not always a one-to-one correspondence
 between connection sockets and processes. In fact, today’s high-performing Web servers often use only
 one process, and create a new thread with a new connection socket for each new client connection.
 #+END_QUOTE
*** 3.3 Connectionless Transport: UDP
    :PROPERTIES:
    :NOTER_PAGE: 238
    :END:
**** some applications are better suited for UDP for the following reasons:
	 :PROPERTIES:
	 :NOTER_PAGE: 239
	 :HIGHLIGHT: #s(pdf-highlight 239 ((0.5591861898890259 0.10612435717625059 0.30209617755856966 0.13370733987844788)))
	 :END:
	 - Finer application-level control over what data is sent, and when. Under UDP, as soon as an application process passes data to UDP, UDP will package the data inside a UDP segment and immediately pass the segment to the network layer. TCP, on the other hand, has a congestion-control mechanism that throttles the transport-layer TCP sender when one or more links between the source and destination hosts become excessively congested. TCP will also continue to resend a segment until the receipt of the segment has been acknowledged by the destination, regardless of how long reliable delivery takes.
	 - No connection establishment. As we’ll discuss later, TCP uses a three-way handshake before it starts to transfer data. UDP just blasts away without any formal preliminaries. Thus UDP does not introduce any delay to establish a connection.
	 - a server devoted to a particular application can typically support many more active clients when the application runs over UDP rather than TCP.
	 - Small packet header overhead. The TCP segment has 20 bytes of header overhead in every segment, whereas UDP has only 8 bytes of overhead.
	 - No connection state.
	 :PROPERTIES:
	 :NOTER_PAGE: 239
	 :HIGHLIGHT: #s(pdf-highlight 239 ((0.11652281134401973 0.6250584385226742 0.26202219482120837 0.6227208976157083)))
	 :END:
**** Lack of congestion control in UDP
	 :PROPERTIES:
	 :NOTER_PAGE: 240
	 :HIGHLIGHT: #s(pdf-highlight 240 ((0.30209617755856966 0.9069658719027583 0.840937114673243 0.9223936418887331)))
	 :END:
 #+BEGIN_QUOTE
  can result in high loss rates between a
 UDP sender and receiver, and the crowding out of TCP sessions—a potentially serious problem
 #+END_QUOTE
**** The UDP header has only four fields, each consisting of two bytes.
	 :PROPERTIES:
	 :NOTER_PAGE: 241
	 :HIGHLIGHT: #s(pdf-highlight 241 ((0.0906288532675709 0.4838709677419355 0.5881627620221949 0.4777933613838242)))
	 :END:

**** Figure 3.7 UDP segment structure
	 :PROPERTIES:
	 :NOTER_PAGE: 242
	 :HIGHLIGHT: #s(pdf-highlight 242 ((0.07151664611590629 0.25245441795231416 0.35141800246609123 0.2575970079476391)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-10-28 18:40:45
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_18-40-45_screenshot.png]]

**** Checksum calculation
	 :PROPERTIES:
	 :NOTER_PAGE: 242
	 :HIGHLIGHT: #s(pdf-highlight 242 ((0.07829839704069051 0.32071061243571763 0.28298397040690504 0.36652641421224874)))
	 :END:
 #+BEGIN_QUOTE
 UDP at the sender side performs the 1s complement of the sum of all the 16-bit words in the segment,
 with any overflow encountered during the sum being wrapped around. This result is put in the checksum
 field of the UDP segment.
 #+END_QUOTE

**** Checksum verification
	 :PROPERTIES:
	 :NOTER_PAGE: 242
	 :HIGHLIGHT: #s(pdf-highlight 242 ((0.9180024660912454 0.9303412809724171 0.688039457459926 0.9303412809724171)))
	 :END:
 #+BEGIN_QUOTE
 At the receiver, all 16-bit words are added, including the checksum. If no errors are introduced into the packet, then clearly the
 sum at the receiver will be 1111111111111111. If one of the bits is a 0, then we know that errors have
 been introduced into the packet.
 #+END_QUOTE

**** No recovery from error
	 :PROPERTIES:
	 :NOTER_PAGE: 243
	 :HIGHLIGHT: #s(pdf-highlight 243 ((0.4432799013563502 0.43525011687704535 0.5869297163995068 0.48106591865357645)))
	 :END:
 #+BEGIN_QUOTE
 Although UDP provides error checking, it does not do
 anything to recover from an error. Some implementations of UDP simply discard the damaged segment;
 others pass the damaged segment to the application with a warning.
 #+END_QUOTE
**** End-to-end principle 
 #+BEGIN_QUOTE
 In networks designed according to this principle, guaranteeing certain application-specific features, such as reliability and security, requires that they reside in the communicating end nodes of the network. Intermediary nodes, such as gateways and routers, that exist to establish the network, may implement these to improve efficiency but cannot guarantee end-to-end correctness.
 #+END_QUOTE
*** 3.4 Principles of Reliable Data Transfer
    :PROPERTIES:
    :NOTER_PAGE: 244
    :END:
**** Build a reliable protocol on top of an unreliable protocol
	 :PROPERTIES:
	 :NOTER_PAGE: 244
	 :HIGHLIGHT: #s(pdf-highlight 244 ((0.07336621454993834 0.46657316503038804 0.3625154130702836 0.5310892940626462)))
	 :END:
 #+BEGIN_QUOTE
 It is the responsibility of a reliable data transfer protocol to implement this service abstraction. This
 task is made difficult by the fact that the layer below the reliable data transfer protocol may be
 unreliable. For example, TCP is a reliable data transfer protocol that is implemented on top of an
 unreliable (IP) end-to-end network layer.
 #+END_QUOTE
**** Figure 3.8 Reliable data transfer: Service model and service implementation
	 :PROPERTIES:
	 :NOTER_PAGE: 245
	 :HIGHLIGHT: #s(pdf-highlight 245 ((0.08014796547472257 0.48059841047218327 0.7583230579531443 0.48620850864890136)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-10-28 18:55:24
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_18-55-24_screenshot.png]]
 #+DOWNLOADED: screenshot @ 2023-10-28 18:55:34
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_18-55-34_screenshot.png]]
**** Reliable Data Transfer over a Perfectly Reliable Channel: rdt1.0
	 :PROPERTIES:
	 :NOTER_PAGE: 246
	 :HIGHLIGHT: #s(pdf-highlight 246 ((0.07768187422934648 0.74520804114072 0.5789149198520346 0.7424029920523609)))
	 :END:
**** It is important to note that there are separate FSMs for the sender and for the receiver.
	 :PROPERTIES:
	 :NOTER_PAGE: 246
	 :HIGHLIGHT: #s(pdf-highlight 246 ((0.6966707768187423 0.8527349228611502 0.5493218249075216 0.8742402992052362)))
	 :END:
**** Figure 3.9 rdt1.0 – A protocol for a completely reliable channel
	 :PROPERTIES:
	 :NOTER_PAGE: 247
	 :HIGHLIGHT: #s(pdf-highlight 247 ((0.08692971639950678 0.6764843384759234 0.6294697903822442 0.6816269284712483)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-10-28 18:59:26
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_18-59-26_screenshot.png]]

**** FSM symbols' meaning
	 :PROPERTIES:
	 :NOTER_PAGE: 247
	 :HIGHLIGHT: #s(pdf-highlight 247 ((0.07953144266337854 0.05189340813464236 0.46609124537607893 0.08508648901355774)))
	 :END:
 #+BEGIN_QUOTE
 The event causing the transition is shown above the horizontal line labeling the transition, and the actions taken when the
 event occurs are shown below the horizontal line. The initial state of the FSM is indicated by the dashed arrow.
 #+END_QUOTE

**** Everything is too perfect
	 :PROPERTIES:
	 :NOTER_PAGE: 247
	 :HIGHLIGHT: #s(pdf-highlight 247 ((0.07521578298397041 0.8859280037400655 0.5776818742293465 0.9256661991584854)))
	 :END:
 #+BEGIN_QUOTE
 In this simple protocol, there is no difference between a unit of data and a packet. Also, all packet flow is
 from the sender to receiver; with a perfectly reliable channel there is no need for the receiver side to
 provide any feedback to the sender since nothing can go wrong!
 #+END_QUOTE

**** Reliable Data Transfer over a Channel with Bit Errors: rdt2.0
	 :PROPERTIES:
	 :NOTER_PAGE: 248
	 :HIGHLIGHT: #s(pdf-highlight 248 ((0.07274969173859433 0.12669471715755026 0.5530209617755857 0.1482000935016363)))
	 :END:

**** Positive acknowledgements and negative acknowledgements
	 :PROPERTIES:
	 :NOTER_PAGE: 248
	 :HIGHLIGHT: #s(pdf-highlight 248 ((0.344019728729963 0.30247779336138386 0.47718865598027127 0.3899018232819075)))
	 :END:
 #+BEGIN_QUOTE
 Consider how you yourself might dictate a long message over the
 phone. In a typical scenario, the message taker might say “OK” after each sentence has been heard,
 understood, and recorded. If the message taker hears a garbled sentence, you’re asked to repeat the
 garbled sentence. This message-dictation protocol uses both positive acknowledgments (“OK”) and
 negative acknowledgments (“Please repeat that.”).
 #+END_QUOTE

**** Automatic Repeat reQuest (ARQ)
	 :PROPERTIES:
	 :NOTER_PAGE: 248
	 :HIGHLIGHT: #s(pdf-highlight 248 ((0.23921085080147966 0.4403927068723703 0.6664611590628854 0.45909303412809727)))
	 :END:
 #+BEGIN_QUOTE
 In a computer network setting, reliable data transfer protocols based on such
 retransmission are known as ARQ (Automatic Repeat reQuest) protocols.
 #+END_QUOTE

**** three additional protocol capabilities are required in ARQ protocols to handle the presence of bit errors:
	 - Error detection, checksum field
	 - Receiver feedback. The positive (ACK) and negative (NAK) acknowledgment
	 - Retransmission.
**** Figure 3.10 rdt2.0 – A protocol for a channel with bit errors
	 :PROPERTIES:
	 :NOTER_PAGE: 249
	 :HIGHLIGHT: #s(pdf-highlight 249 ((0.08384710234278668 0.541374474053296 0.5758323057953144 0.5507246376811594)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-10-28 19:11:51
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_19-11-51_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2023-10-28 19:12:01
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_19-12-01_screenshot.png]]

**** wait-for-ACK-or-NAK blocks
	 :PROPERTIES:
	 :NOTER_PAGE: 250
	 :HIGHLIGHT: #s(pdf-highlight 250 ((0.3273736128236745 0.05469845722300141 0.6442663378545006 0.09724170172978028)))
	 :END:
 #+BEGIN_QUOTE
 It is important to note that when the sender is in the wait-for-ACK-or-NAK
 state, it cannot get more data from the upper layer; that is, the rdt_send() event can not occur; that
 will happen only after the sender receives an ACK and leaves this state. Because of
 this behavior, protocols such as rdt2.0 are known as stop-and-wait protocols.
 #+END_QUOTE

**** Flaw of rdt2.0
	 :PROPERTIES:
	 :NOTER_PAGE: 250
	 :HIGHLIGHT: #s(pdf-highlight 250 ((0.08138101109741061 0.31369798971482005 0.6763255240443896 0.3398784478728378)))
	 :END:
 #+BEGIN_QUOTE
 Protocol rdt2.0 may look as if it works but, unfortunately, it has a fatal flaw. In particular, we haven’t
 accounted for the possibility that the ACK or NAK packet could be corrupted! Minimally, we will need to add checksum bits to ACK/NAK packets in order
 to detect such errors.
 #+END_QUOTE

 #+BEGIN_QUOTE
 The more difficult question is how the protocol should recover from errors in ACK
 or NAK packets. The difficulty here is that if an ACK or NAK is corrupted, the sender has no way of
 knowing whether or not the receiver has correctly received the last piece of transmitted data.
 #+END_QUOTE

**** possibilities for handling corrupted ACKs or NAKs:
	 :PROPERTIES:
	 :NOTER_PAGE: 250
	 :HIGHLIGHT: #s(pdf-highlight 250 ((0.20530209617755857 0.4927536231884058 0.5887792848335388 0.49976624590930346)))
	 :END:

**** Notes for page 250
	 :PROPERTIES:
	 :NOTER_PAGE: 250
	 :HIGHLIGHT: #s(pdf-highlight 250 ((0.11282367447595561 0.6989247311827957 0.25400739827373614 0.7466105656848995)))
	 :END:
 #+BEGIN_QUOTE
 Add enough checksum bits to allow the sender not only to detect, but also
 to recover from, bit errors. This solves the immediate problem for a channel that can corrupt packets
 but not lose them.
 #+END_QUOTE

 #+BEGIN_QUOTE
 for the sender simply to resend the current data packet when it receives a
 garbled ACK or NAK packet. This approach, however, introduces duplicate packets into the
 sender-to-receiver channel. The fundamental difficulty with duplicate packets is that the receiver
 doesn’t know whether the ACK or NAK it last sent was received correctly at the sender. Thus, it
 cannot know a priori whether an arriving packet contains new data or is a retransmission!
 #+END_QUOTE

**** Sequence number
	 :PROPERTIES:
	 :NOTER_PAGE: 250
	 :HIGHLIGHT: #s(pdf-highlight 250 ((0.08014796547472257 0.8934081346423562 0.3964241676942047 0.9438990182328191)))
	 :END:
 #+BEGIN_QUOTE
 A simple solution to this new problem (and one adopted in almost all existing data transfer protocols,
 including TCP) is to add a new field to the data packet and have the sender number its data packets by
 putting a sequence number into this field.
 #+END_QUOTE
 #+BEGIN_QUOTE
 For this simple case of a stop-and-
 wait protocol, a 1-bit sequence number will suffice, since it will allow the receiver to know whether the
 sender is resending the previously transmitted packet (the sequence number of the received packet has
 the same sequence number as the most recently received packet) or a new packet (the sequence
 number changes, moving “forward” in modulo-2 arithmetic).
 #+END_QUOTE

**** Figure 3.11 rdt2.1 sender
	 :PROPERTIES:
	 :NOTER_PAGE: 251
	 :HIGHLIGHT: #s(pdf-highlight 251 ((0.07953144266337854 0.9336138382421693 0.37422934648581996 0.9270687237026648)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-10-28 19:26:08
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_19-26-08_screenshot.png]]

**** Figure 3.12 rdt2.1 receiver
	 :PROPERTIES:
	 :NOTER_PAGE: 252
	 :HIGHLIGHT: #s(pdf-highlight 252 ((0.34155363748458695 0.44086021505376344 0.09124537607891492 0.4324450677886863)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-10-28 19:27:11
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_19-27-11_screenshot.png]]

**** NAK-free reliable data transfer protocol rdt2.2
	 :PROPERTIES:
	 :NOTER_PAGE: 252
	 :HIGHLIGHT: #s(pdf-highlight 252 ((0.5635018495684341 0.5035063113604489 0.8249075215782984 0.5857877512856475)))
	 :END:
 #+BEGIN_QUOTE
 We can accomplish the same effect as a
 NAK if, instead of sending a NAK, we send an ACK for the last correctly received packet. A sender that
 receives two ACKs for the same packet (that is, receives duplicate ACKs) knows that the receiver did
 not correctly receive the packet following the packet that is being ACKed twice. Our NAK-free reliable
 data transfer protocol for a channel with bit errors is rdt2.2 , shown in Figures 3.13 and 3.14.
 #+END_QUOTE

**** rdt2.1 vs rdt2.2
	 :PROPERTIES:
	 :NOTER_PAGE: 252
	 :HIGHLIGHT: #s(pdf-highlight 252 ((0.6017262638717633 0.7227676484338477 0.845252774352651 0.5881252921926134)))
	 :END:
 #+BEGIN_QUOTE
 One
 subtle change between rtdt2.1 and rdt2.2 is that the receiver must now include the sequence
 number of the packet being acknowledged by an ACK message (this is done by including the ACK , 0
 or ACK , 1 argument in make_pkt() in the receiver FSM), and the sender must now check the
 sequence number of the packet being acknowledged by a received ACK message (this is done by
 including the 0 or 1 argument in isACK() in the sender FSM).
 #+END_QUOTE
**** Figure 3.13 rdt2.2 sender
	 :PROPERTIES:
	 :NOTER_PAGE: 253
	 :HIGHLIGHT: #s(pdf-highlight 253 ((0.05363748458692972 0.4787283777466106 0.28175092478421704 0.5039738195418421)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-10-28 19:39:15
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_19-39-15_screenshot.png]]
 
**** Figure 3.14 rdt2.2 receiver
	 :PROPERTIES:
	 :NOTER_PAGE: 254
	 :HIGHLIGHT: #s(pdf-highlight 254 ((0.08199753390875462 0.37587657784011225 0.3064118372379778 0.38803179055633474)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-10-28 19:46:38
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-28_19-46-38_screenshot.png]]

**** rdt3.0, a protocol that reliably transfers data over a channel that can corrupt or lose packets;
	 :PROPERTIES:
	 :NOTER_PAGE: 254
	 :HIGHLIGHT: #s(pdf-highlight 254 ((0.4030395136778116 0.8086675887505763 0.33981762917933134 0.8358690640848317)))
	 :END:
**** Figure 3.15 rdt3.0 sender
	 :PROPERTIES:
	 :NOTER_PAGE: 255
	 :HIGHLIGHT: #s(pdf-highlight 255 ((0.08428093645484949 0.5070993914807302 0.325752508361204 0.5101419878296146)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-10-31 13:01:27
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-10-31_13-01-27_screenshot.png]]
**** Alternating-bit protocol
	 :PROPERTIES:
	 :NOTER_PAGE: 255
	 :HIGHLIGHT: #s(pdf-highlight 255 ((0.5294832826747721 0.6449976947902258 0.7793313069908815 0.665283540802213)))
	 :END:
 #+BEGIN_QUOTE
 Because packet sequence numbers alternate
 between 0 and 1, protocol rdt3.0 is sometimes known as the alternating-bit protocol
 #+END_QUOTE
**** Figure 3.16 Operation of rdt3.0 , the alternating-bit protocol
	 :PROPERTIES:
	 :NOTER_PAGE: 256
	 :HIGHLIGHT: #s(pdf-highlight 256 ((0.08024316109422493 0.545412632549562 0.6212765957446809 0.5606270170585523)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 20:55:42
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_20-55-42_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2023-11-01 20:55:58
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_20-55-58_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2023-11-01 20:57:34
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_20-57-34_screenshot.png]]

 #+DOWNLOADED: screenshot @ 2023-11-01 20:57:43
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_20-57-43_screenshot.png]]
**** Utilization of the channel
	 :PROPERTIES:
	 :NOTER_PAGE: 258
	 :HIGHLIGHT: #s(pdf-highlight 258 ((0.1872340425531915 0.7242969110189027 0.2632218844984803 0.8280313508529276)))
	 :END:
 #+BEGIN_QUOTE
 If we define the utilization of the sender (or the channel) as the fraction of time the sender
 is actually busy sending bits into the channel, the analysis in Figure 3.18(a) shows that the stop-and-
 wait protocol has a rather dismal sender utilization, Usender, of
 Usender= (L/R) / (RTT+L/R)
 #+END_QUOTE
**** Figure 3.18 Stop-and-wait and pipelined sending
	 :PROPERTIES:
	 :NOTER_PAGE: 259
	 :HIGHLIGHT: #s(pdf-highlight 259 ((0.07294832826747721 0.3706777316735823 0.5270516717325229 0.3946519133241125)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 21:05:02
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_21-05-02_screenshot.png]]
**** Go-Back-N (GBN)
	 :PROPERTIES:
	 :NOTER_PAGE: 260
	 :HIGHLIGHT: #s(pdf-highlight 260 ((0.08145896656534955 0.5846011987090826 0.5848024316109423 0.6366989396035039)))
	 :END:
 #+BEGIN_QUOTE
 In a Go-Back-N (GBN) protocol, the sender is allowed to transmit multiple packets (when available)
 without waiting for an acknowledgment, but is constrained to have no more than some maximum
 allowable number, N, of unacknowledged packets in the pipeline.
 #+END_QUOTE
**** Figure 3.19 Sender’s view of sequence numbers in Go-Back-N
	 :PROPERTIES:
	 :NOTER_PAGE: 260
	 :HIGHLIGHT: #s(pdf-highlight 260 ((0.08145896656534955 0.9294605809128631 0.5829787234042554 0.9345320424158599)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 21:09:12
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_21-09-12_screenshot.png]]
**** Sequence numbers
	 :PROPERTIES:
	 :NOTER_PAGE: 261
	 :HIGHLIGHT: #s(pdf-highlight 261 ((0.8316109422492401 0.5191332411249423 0.7112462006079028 0.6131857999077915)))
	 :END:
 #+BEGIN_QUOTE
 If k is the
 number of bits in the packet sequence number field, the range of sequence numbers is thus [0, 2^k − 1].
 With a finite range of sequence numbers, all arithmetic involving sequence numbers must then be done
 using modulo 2^k arithmetic. (That is, the sequence number space can be thought of as a ring of size 2k,
 where sequence number 2^k−1 is immediately followed by sequence number 0.)
 #+END_QUOTE
**** Figure 3.20 Extended FSM description of the GBN sender
	 :PROPERTIES:
	 :NOTER_PAGE: 262
	 :HIGHLIGHT: #s(pdf-highlight 262 ((0.5811550151975684 0.4656523743660673 0.1142857142857143 0.4730290456431535)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 21:14:19
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_21-14-19_screenshot.png]]
**** Figure 3.21 Extended FSM description of the GBN receiver
	 :PROPERTIES:
	 :NOTER_PAGE: 262
	 :HIGHLIGHT: #s(pdf-highlight 262 ((0.5975683890577508 0.7976025818349469 0.08145896656534955 0.7962194559704933)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 21:14:32
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_21-14-32_screenshot.png]]
**** Why discard out of order packets?
	 :PROPERTIES:
	 :NOTER_PAGE: 263
	 :HIGHLIGHT: #s(pdf-highlight 263 ((0.08571428571428572 0.8197325956662056 0.8316109422492401 0.8464730290456431)))
	 :END:
 #+BEGIN_QUOTE
 In our GBN protocol, the receiver discards out-of-order packets. Although it may seem silly and wasteful
 to discard a correctly received (but out-of-order) packet, there is some justification for doing so.
 The advantage of this approach is the simplicity of receiver buffering—the receiver need not buffer any out-
 of-order packets.
 #+END_QUOTE
**** Figure 3.22 Go-Back-N in operation
	 :PROPERTIES:
	 :NOTER_PAGE: 265
	 :HIGHLIGHT: #s(pdf-highlight 265 ((0.08145896656534955 0.6399262332872291 0.40060790273556235 0.6537574919317658)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 21:21:38
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_21-21-38_screenshot.png]]
**** Figure 3.23 Selective-repeat (SR) sender and receiver views of sequence-number space
	 :PROPERTIES:
	 :NOTER_PAGE: 266
	 :HIGHLIGHT: #s(pdf-highlight 266 ((0.07416413373860183 0.8317196864914707 0.9167173252279636 0.875979714153988)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 21:25:02
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_21-25-02_screenshot.png]]
**** packets are buffered
	 :PROPERTIES:
	 :NOTER_PAGE: 266
	 :HIGHLIGHT: #s(pdf-highlight 266 ((0.08145896656534955 0.28769017980636236 0.7641337386018238 0.33609958506224064)))
	 :END:
 #+BEGIN_QUOTE
 The SR receiver will acknowledge a correctly received packet whether or not it is in order. Out-of-order
 packets are buffered until any missing packets (that is, packets with lower sequence numbers) are
 received, at which point a batch of packets can be delivered in order to the upper layer.
 #+END_QUOTE
**** In SR protocols, sender and receiver windows will not always coincide.
	 :PROPERTIES:
	 :NOTER_PAGE: 268
	 :HIGHLIGHT: #s(pdf-highlight 268 ((0.23890577507598787 0.8423236514522822 0.6437689969604864 0.8515444905486399)))
	 :END:
**** Window size to avoid confusion
	 :PROPERTIES:
	 :NOTER_PAGE: 269
	 :HIGHLIGHT: #s(pdf-highlight 269 ((0.6668693009118541 0.46473029045643155 0.6510638297872341 0.43107422775472565)))
	 :END:
 #+BEGIN_QUOTE
 window size must be less than
 or equal to half the size of the sequence number space for SR protocols.
 #+END_QUOTE
**** Figure 3.27 SR receiver dilemma with too-large windows: A new packet or a retransmission?
	 :PROPERTIES:
	 :NOTER_PAGE: 270
	 :HIGHLIGHT: #s(pdf-highlight 270 ((0.08693009118541034 0.3545412632549562 0.8613981762917934 0.3656062701705855)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 21:35:09
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_21-35-09_screenshot.png]]

**** each packet has its own logic timer
*** 3.5 Connection-Oriented Transport: TCP
    :PROPERTIES:
    :NOTER_PAGE: 272
    :END:
**** TCP is point-to-point
	 :PROPERTIES:
	 :NOTER_PAGE: 272
	 :HIGHLIGHT: #s(pdf-highlight 272 ((0.7896656534954408 0.7777777777777778 0.3331306990881459 0.8662978331028124)))
	 :END:
 #+BEGIN_QUOTE
 A. A TCP
 connection is also always point-to-point, that is, between a single sender and a single receiver. So-
 called “multicasting” (see the online supplementary materials for this text)—the transfer of data from one
 sender to many receivers in a single send operation—is not possible with TCP. With TCP, two hosts are
 company and three are a crowd!
 #+END_QUOTE
**** MSS and MTU
	 :PROPERTIES:
	 :NOTER_PAGE: 274
	 :HIGHLIGHT: #s(pdf-highlight 274 ((0.3860182370820669 0.30059935454126324 0.25045592705167175 0.4167819271553711)))
	 :END:
 #+BEGIN_QUOTE
 The maximum amount of data that can be grabbed and placed in
 a segment is limited by the maximum segment size (MSS). The MSS is typically set by first
 determining the length of the largest link-layer frame that can be sent by the local sending host (the so-
 called maximum transmission unit, MTU), and then setting the MSS to ensure that a TCP segment
 (when encapsulated in an IP datagram) plus the TCP/IP header length (typically 40 bytes) will fit into a
 single link-layer frame.
 Note that the MSS is the maximum amount of
 application-layer data in the segment, not the maximum size of the TCP segment including headers.
 #+END_QUOTE
**** TCP segments
	 :PROPERTIES:
	 :NOTER_PAGE: 274
	 :HIGHLIGHT: #s(pdf-highlight 274 ((0.07416413373860183 0.5615491009681881 0.7951367781155015 0.5693868142000922)))
	 :END:
 #+BEGIN_QUOTE
 TCP pairs each chunk of client data with a TCP header, thereby forming TCP segments.
 #+END_QUOTE
**** TCP components
	 :PROPERTIES:
	 :NOTER_PAGE: 275
	 :HIGHLIGHT: #s(pdf-highlight 275 ((0.3617021276595745 0.14246196403872752 0.6753799392097265 0.21392346703550022)))
	 :END:
 #+BEGIN_QUOTE
 TCP connection consists of buffers, variables, and a socket
 connection to a process in one host, and another set of buffers, variables, and a socket connection to a
 process in another host. As mentioned earlier, no buffers or variables are allocated to the connection in
 the network elements (routers, switches, and repeaters) between the hosts.
 #+END_QUOTE
**** Header length field
	 :PROPERTIES:
	 :NOTER_PAGE: 275
	 :HIGHLIGHT: #s(pdf-highlight 275 ((0.11671732522796353 0.7574919317657907 0.558662613981763 0.8063623789764869)))
	 :END:
 #+BEGIN_QUOTE
 The 4-bit header length field specifies the length of the TCP header in 32-bit words. The TCP
 header can be of variable length due to the TCP options field. (Typically, the options field is empty,
 so that the length of the typical TCP header is 20 bytes.)
 #+END_QUOTE
**** Options field
	 :PROPERTIES:
	 :NOTER_PAGE: 275
	 :HIGHLIGHT: #s(pdf-highlight 275 ((0.11550151975683891 0.8275703088981097 0.8267477203647416 0.8584601198709082)))
	 :END:
 #+BEGIN_QUOTE
 The optional and variable-length options field is used when a sender and receiver negotiate the
 maximum segment size (MSS) or as a window scaling factor for use in high-speed networks.
 #+END_QUOTE
**** Figure 3.29 TCP segment structure
	 :PROPERTIES:
	 :NOTER_PAGE: 276
	 :HIGHLIGHT: #s(pdf-highlight 276 ((0.1082066869300912 0.44029506685108344 0.4109422492401216 0.45504840940525587)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 21:46:58
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_21-46-58_screenshot.png]]
**** PSH flag
	 :PROPERTIES:
	 :NOTER_PAGE: 276
	 :HIGHLIGHT: #s(pdf-highlight 276 ((0.16170212765957448 0.5587828492392808 0.2127659574468085 0.5726141078838174)))
	 :END:
 #+BEGIN_QUOTE
 Setting the PSH bit indicates that the receiver should pass the data to the upper layer
 immediately.
 #+END_QUOTE
**** URG flag
	 :PROPERTIES:
	 :NOTER_PAGE: 276
	 :HIGHLIGHT: #s(pdf-highlight 276 ((0.22127659574468087 0.5795297372060857 0.5300911854103344 0.6053480866758875)))
	 :END:
 #+BEGIN_QUOTE
 Finally, the URG bit is used to indicate that there is data in this segment that the
 sending-side upper-layer entity has marked as “urgent.”
 #+END_QUOTE
**** Sequnce number for a segmnet
	 :PROPERTIES:
	 :NOTER_PAGE: 277
	 :HIGHLIGHT: #s(pdf-highlight 277 ((0.4121580547112462 0.6366989396035039 0.6468085106382979 0.6560627017058552)))
	 :END:
 #+BEGIN_QUOTE
 TCP’s use of sequence numbers
 reflects this view in that sequence numbers are over the stream of transmitted bytes and not over the
 series of transmitted segments. The sequence number for a segment is therefore the byte-stream
 number of the first byte in the segment.
 The acknowledgment number that Host A puts in its segment is
 the sequence number of the next byte Host A is expecting from Host B.
 #+END_QUOTE
**** TCP is said to provide cumulative acknowledgments.
	 :PROPERTIES:
	 :NOTER_PAGE: 277
	 :HIGHLIGHT: #s(pdf-highlight 277 ((0.843161094224924 0.8879668049792531 0.46990881458966566 0.909174734900876)))
	 :END:
**** What does a host do when it receives out-of-order segments in a TCP connection?
	 :PROPERTIES:
	 :NOTER_PAGE: 278
	 :HIGHLIGHT: #s(pdf-highlight 278 ((0.4772036474164134 0.09866297833102812 0.6164133738601825 0.14430613185799906)))
	 :END:
 #+BEGIN_QUOTE
  Interestingly, the TCP RFCs do not impose any rules here and leave
 the decision up to the programmers implementing a TCP implementation.
 #+END_QUOTE
**** Figure 3.31 Sequence and acknowledgment numbers for a simple Telnet application over TCP
	 :PROPERTIES:
	 :NOTER_PAGE: 279
	 :HIGHLIGHT: #s(pdf-highlight 279 ((0.08389057750759879 0.4762563393268787 0.8644376899696049 0.4891655140617796)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 21:59:25
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_21-59-25_screenshot.png]]
**** Client and server know what to expect
	 :PROPERTIES:
	 :NOTER_PAGE: 279
	 :HIGHLIGHT: #s(pdf-highlight 279 ((0.5531914893617021 0.5431074227754725 0.793920972644377 0.5656984785615491)))
	 :END:
 #+BEGIN_QUOTE
 After the TCP connection is established but
 before any data is sent, the client is waiting for byte 79 and the server is waiting for byte 42.
 #+END_QUOTE
**** Estimated RTT
	 :PROPERTIES:
	 :NOTER_PAGE: 281
	 :HIGHLIGHT: #s(pdf-highlight 281 ((0.11975683890577508 0.14615029967727064 0.5963525835866261 0.13416320885200553)))
	 :END:
 #+begin_quote
 EstimatedRTT=(1−α)⋅EstimatedRTT+α⋅SampleRTT
 The recommended value of α is α = 0.125 (that is, 1/8)
 In statistics, such an average is called an exponential weighted moving average (EWMA).
 #+END_QUOTE
**** Variability of RTT
	 :PROPERTIES:
	 :NOTER_PAGE: 281
	 :HIGHLIGHT: #s(pdf-highlight 281 ((0.11306990881458967 0.8151221761180267 0.5866261398176292 0.8105117565698479)))
	 :END:
 #+BEGIN_QUOTE
 DevRTT=(1−β)⋅DevRTT+β⋅|SampleRTT−EstimatedRTT|
 Note that DevRTT is an EWMA of the difference between SampleRTT and EstimatedRTT . If the
 SampleRTT values have little fluctuation, then DevRTT will be small; on the other hand, if there is a lot
 of fluctuation, DevRTT will be large. The recommended value of β is 0.25.
 #+END_QUOTE
**** TCP timeout interval
	 :PROPERTIES:
	 :NOTER_PAGE: 282
	 :HIGHLIGHT: #s(pdf-highlight 282 ((0.08632218844984803 0.10880590133702167 0.9416413373860183 0.12079299216228677)))
	 :END:
 #+BEGIN_QUOTE
 Given values of EstimatedRTT and DevRTT , what value should be used for TCP’s timeout interval?
 It is desirable to set the timeout
 equal to the EstimatedRTT plus some margin. The margin should be large when there is a lot of
 fluctuation in the SampleRTT values; it should be small when there is little fluctuation.
 TimeoutInterval=EstimatedRTT+4⋅DevRTT
 #+END_QUOTE
**** 
	 :PROPERTIES:
	 :NOTER_PAGE: 282
	 :HIGHLIGHT: #s(pdf-highlight 282 ((0.5392097264437691 0.8556938681420009 0.23282674772036477 0.863531581373905)))
	 :END:

**** Figure 3.32 RTT samples and RTT estimates
	 :PROPERTIES:
	 :NOTER_PAGE: 283
	 :HIGHLIGHT: #s(pdf-highlight 283 ((0.09179331306990882 0.5094513600737667 0.4650455927051672 0.5099124020285846)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 22:11:35
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_22-11-35_screenshot.png]]

**** Fast retransmit
	 :PROPERTIES:
	 :NOTER_PAGE: 289
	 :HIGHLIGHT: #s(pdf-highlight 289 ((0.07781155015197569 0.5712309820193637 0.5167173252279635 0.722913785154449)))
	 :END:
 #+BEGIN_QUOTE
 Because a sender often sends a large number of segments back to back, if one segment is lost, there
 will likely be many back-to-back duplicate ACKs. If the TCP sender receives three duplicate ACKs for
 the same data, it takes this as an indication that the segment following the segment that has been
 ACKed three times has been lost. In the case that three
 duplicate ACKs are received, the TCP sender performs a fast retransmit [RFC 5681], retransmitting
 the missing segment before that segment’s timer expires.
 #+END_QUOTE

**** Figure 3.37 Fast retransmit: retransmitting the missing segment before the segment’s timer expires
	 :PROPERTIES:
	 :NOTER_PAGE: 290
	 :HIGHLIGHT: #s(pdf-highlight 290 ((0.07902735562310031 0.6016597510373444 0.1574468085106383 0.6214845550945136)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 22:28:08
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_22-28-08_screenshot.png]]

**** TCP is both GBN and SR
	 :PROPERTIES:
	 :NOTER_PAGE: 291
	 :HIGHLIGHT: #s(pdf-highlight 291 ((0.374468085106383 0.33609958506224064 0.3677811550151976 0.38312586445366525)))
	 :END:
 #+BEGIN_QUOTE
 TCP looks a lot like a GBN-style protocol. But there are some
 striking differences between TCP and Go-Back-N. Many TCP implementations will buffer correctly
 received but out-of-order segments
 #+END_QUOTE

**** Flow-control
	 :PROPERTIES:
	 :NOTER_PAGE: 292
	 :HIGHLIGHT: #s(pdf-highlight 292 ((0.08389057750759879 0.059474412171507604 0.3325227963525836 0.08990318118948824)))
	 :END:
 #+BEGIN_QUOTE
 TCP provides a flow-control service to its applications to eliminate the possibility of the sender
 overflowing the receiver’s buffer.
 #+END_QUOTE

**** Congestion control
	 :PROPERTIES:
	 :NOTER_PAGE: 292
	 :HIGHLIGHT: #s(pdf-highlight 292 ((0.1452887537993921 0.13831258644536654 0.44316109422492406 0.16551406177962194)))
	 :END:
 #+BEGIN_QUOTE
 a TCP sender can also be throttled due to congestion within the IP network; this form of sender
 control is referred to as congestion control,
 #+END_QUOTE

**** Flow-control at receiver side
	 :PROPERTIES:
	 :NOTER_PAGE: 292
	 :HIGHLIGHT: #s(pdf-highlight 292 ((0.11550151975683891 0.5232826187183034 0.4966565349544073 0.5915168280313509)))
	 :END:
 #+BEGIN_QUOTE
 LastByteRead : the number of the last byte in the data stream read from the buffer by the
 application process in B
 LastByteRcvd : the number of the last byte in the data stream that has arrived from the network
 and has been placed in the receive buffer at B.
 Because TCP is not permitted to overflow the allocated buffer, we must have

 LastByteRcvd−LastByteRead≤RcvBuffer

 The receive window, denoted rwnd is set to the amount of spare room in the buffer:

 rwnd=RcvBuffer−[LastByteRcvd−LastByteRead]
 #+END_QUOTE

**** Flow-control at sender side
	 :PROPERTIES:
	 :NOTER_PAGE: 293
	 :HIGHLIGHT: #s(pdf-highlight 293 ((0.1033434650455927 0.16459197786998617 0.1264437689969605 0.2738589211618257)))
	 :END:
 #+BEGIN_QUOTE
 Host A in turn keeps track of two variables, LastByteSent and LastByteAcked , which have
 obvious meanings. Note that the difference between these two variables, LastByteSent –
 LastByteAcked , is the amount of unacknowledged data that A has sent into the connection. By
 keeping the amount of unacknowledged data less than the value of rwnd , Host A is assured that it is
 not overflowing the receive buffer at Host B.
 Thus, Host A makes sure throughout the connection’s life that

 LastByteSent−LastByteAcked≤rwnd
 #+END_QUOTE

**** Figure 3.38 The receive window (rwnd) and the receive buffer (RcvBuffer)
	 :PROPERTIES:
	 :NOTER_PAGE: 293
	 :HIGHLIGHT: #s(pdf-highlight 293 ((0.07355623100303951 0.5398801290917473 0.6620060790273556 0.53711387736284)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 22:38:40
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_22-38-40_screenshot.png]]

**** Figure 3.39 TCP three-way handshake: segment exchange
	 :PROPERTIES:
	 :NOTER_PAGE: 296
	 :HIGHLIGHT: #s(pdf-highlight 296 ((0.08814589665653497 0.46426924850161366 0.5762917933130699 0.4638082065467957)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 22:46:16
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_22-46-16_screenshot.png]]

**** Figure 3.40 Closing a TCP connection
	 :PROPERTIES:
	 :NOTER_PAGE: 297
	 :HIGHLIGHT: #s(pdf-highlight 297 ((0.07537993920972645 0.060396496081143385 0.3939209726443769 0.06685108344859382)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 22:46:38
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_22-46-38_screenshot.png]]

**** Figure 3.41 A typical sequence of TCP states visited by a client TCP
	 :PROPERTIES:
	 :NOTER_PAGE: 297
	 :HIGHLIGHT: #s(pdf-highlight 297 ((0.08389057750759879 0.8847395112955279 0.6492401215805471 0.8690640848317197)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 22:50:03
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_22-50-03_screenshot.png]]

**** payload = application-generated data.
	 :PROPERTIES:
	 :NOTER_PAGE: 298
	 :HIGHLIGHT: #s(pdf-highlight 298 ((0.08267477203647416 0.09774089442139235 0.4243161094224924 0.11433840479483633)))
	 :END:

**** Figure 3.42 A typical sequence of TCP states visited by a server-side TCP
	 :PROPERTIES:
	 :NOTER_PAGE: 298
	 :HIGHLIGHT: #s(pdf-highlight 298 ((0.06521739130434782 0.896960329726945 0.6942934782608695 0.899021123132406)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-01 22:51:42
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-01_22-51-42_screenshot.png]]
 
**** RST flag bit
	 :PROPERTIES:
	 :NOTER_PAGE: 299
	 :HIGHLIGHT: #s(pdf-highlight 299 ((0.8468872686483455 0.1471714164185453 0.4178351093662367 0.188855806039983)))
	 :END:
 #+BEGIN_QUOTE
 What
 happens when a host receives a TCP segment whose port numbers or source IP address do not match
 with any of the ongoing sockets in the host.
 Then the host will send a special reset segment to the source. This TCP
 segment has the RST flag bit (see Section 3.5.2) set to 1. Thus, when a host sends a reset segment, it
 is telling the source “I don’t have a socket for that segment. Please do not resend the segment.”
 #+END_QUOTE
*** 3.6 Principles of Congestion Control
    :PROPERTIES:
    :NOTER_PAGE: 302
    :END:
**** Costs of a congested network
	 - large queuing delays are experienced as the packet-arrival rate nears the link capacity.
	 - the sender must perform retransmissions in order to compensate for dropped (lost) packets due to buffer overflow.
	 - unneeded retransmissions by the sender in the face of large delays may cause a router to use its link bandwidth to forward unneeded copies of a packet.
	 - when a packet is dropped along a path, the transmission capacity that was used at each of the upstream links to forward that packet to the point at which it is dropped ends up having been wasted.
**** Congesti on-control approaches
	 :PROPERTIES:
	 :NOTER_PAGE: 309
	 :HIGHLIGHT: #s(pdf-highlight 309 ((0.12170499158721257 0.16928966397277756 0.5215928210880538 0.23436835389196087)))
	 :END:
 #+BEGIN_QUOTE
 End-to-end congestion control. In an end-to-end approach to congestion control, the network
 layer provides no explicit support to the transport layer for congestion-control purposes. Even the
 presence of network congestion must be inferred by the end systems based only on observed
 network behavior (for example, packet loss and delay).
 #+END_QUOTE

 #+BEGIN_QUOTE
 Network-assisted congestion control. With network-assisted congestion control, routers provide
 explicit feedback to the sender and/or receiver regarding the congestion state of the network.
 #+END_QUOTE
*** 3.7 TCP Congestion Control
    :PROPERTIES:
    :NOTER_PAGE: 311
    :END:
**** Constraint on the rate at which a TCP sender can send traffic into the network
	 :PROPERTIES:
	 :NOTER_PAGE: 311
	 :HIGHLIGHT: #s(pdf-highlight 311 ((0.7757847533632287 0.5852103697407565 0.5672645739910314 0.7250318742031449)))
	 :END:
 #+BEGIN_QUOTE
 The congestion
 window, denoted cwnd , imposes a constraint on the rate at which a TCP sender can send traffic into
 the network. Specifically, the amount of unacknowledged data at a sender may not exceed the minimum
 of cwnd and rwnd , that is:
 LastByteSent−LastByteAcked≤min{cwnd, rwnd}
 #+END_QUOTE
**** Varying congestion window size
	 :PROPERTIES:
	 :NOTER_PAGE: 312
	 :HIGHLIGHT: #s(pdf-highlight 312 ((0.3076474022183304 0.600265604249668 0.6415645067133684 0.4944665781319168)))
	 :END:
 #+BEGIN_QUOTE
 Note that if acknowledgments
 arrive at a relatively slow rate (e.g., if the end-end path has high delay or contains a low-bandwidth link),
 then the congestion window will be increased at a relatively slow rate. On the other hand, if
 acknowledgments arrive at a high rate, then the congestion window will be increased more quickly.
 Because TCP uses acknowledgments to trigger (or clock) its increase in congestion window size, TCP
 is said to be self-clocking.
 #+END_QUOTE
**** TCP congestion-control algorithm
	 :PROPERTIES:
	 :NOTER_PAGE: 313
	 :HIGHLIGHT: #s(pdf-highlight 313 ((0.1766805472932778 0.5493910690121786 0.46519928613920286 0.5453315290933695)))
	 :END:
	 1) Slow Start
	 2) Congestion Avoidance
	 3) Fast Recovery.
**** TCP sending rate principles
	 - A lost segment implies congestion, and hence, the TCP sender’s rate should be decreased when a segment is lost.
	 - An acknowledged segment indicates that the network is delivering the sender’s segments to the receiver, and hence, the sender’s rate can be increased when an ACK arrives for a previously unacknowledged segment.
	 - Bandwidth probing. The TCP sender thus increases its transmission rate to probe for the rate that at which congestion onset begins, backs off from that rate, and then to begins probing again to see if the congestion onset rate has changed.
**** Slow Start
	 - the value of cwnd begins at 1 MSS and increases by 1 MSS every time a transmitted segment is first acknowledged.
     - This process results in a doubling of the sending rate every RTT. Thus, the TCP send rate starts slow but grows exponentially during the slow start phase.
	 - when should this exponential growth end?
	   1) if there is a loss event (i.e., congestion) indicated by a timeout, the TCP sender sets the value of cwnd to 1 and begins the slow start process anew. It also sets the value of a second state variable, ssthresh (shorthand for “slow start threshold”) to cwnd/2 —half of the value of the congestion window value when congestion was detected.
	   2) Since ssthresh is half the value of cwnd when congestion was last detected, it might be a bit reckless to keep doubling cwnd when it reaches or surpasses the value of ssthresh . Thus, when the value of cwnd equals ssthresh , slow start ends and TCP transitions into congestion avoidance mode.
	   3) if three duplicate ACKs are detected, in which case TCP performs a fast retransmit (see Section 3.5.4) and enters the fast recovery state.

**** Congestion Avoidance
	 :PROPERTIES:
	 :NOTER_PAGE: 315
	 :HIGHLIGHT: #s(pdf-highlight 315 ((0.08447352766210589 0.16959855660802886 0.29208804283164785 0.16328371673432565)))
	 :END:
	 - On entry to the congestion-avoidance state, the value of cwnd is approximately half its value when congestion was last encountered—congestion could be just around the corner!
	 - increases the value of cwnd by just a single MSS every RTT

**** Figure 3.51 FSM description of TCP congestion control
	 :PROPERTIES:
	 :NOTER_PAGE: 316
	 :HIGHLIGHT: #s(pdf-highlight 316 ((0.07971445568114219 0.5448804691023906 0.5217132659131469 0.564276048714479)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-04 13:42:02
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-04_13-42-02_screenshot.png]]

**** Fast Recovery
	 :PROPERTIES:
	 :NOTER_PAGE: 316
	 :HIGHLIGHT: #s(pdf-highlight 316 ((0.08625817965496728 0.7577807848443843 0.19631171921475313 0.7595850248082995)))
	 :END:
	 - the value of cwnd is increased by 1 MSS for every duplicate ACK received for the
 missing segment that caused TCP to enter the fast-recovery state.

**** TCP Tahoe vs TCP Reno
	 :PROPERTIES:
	 :NOTER_PAGE: 318
	 :HIGHLIGHT: #s(pdf-highlight 318 ((0.08587088915956151 0.19214780600461895 0.5901339829476249 0.23371824480369516)))
	 :END:
 #+BEGIN_QUOTE
 an early version of TCP, known as TCP Tahoe, unconditionally cut its congestion window to 1 MSS and
 entered the slow-start phase after either a timeout-indicated or triple-duplicate-ACK-indicated loss event.
 The newer version of TCP, TCP Reno, incorporated fast recovery.
 #+END_QUOTE

**** Figure 3.52 Evolution of TCP’s congestion window (Tahoe and Reno)
	 :PROPERTIES:
	 :NOTER_PAGE: 319
	 :HIGHLIGHT: #s(pdf-highlight 319 ((0.07429963459196103 0.31685912240184755 0.6376370280146163 0.3085450346420323)))
	 :END:
 #+DOWNLOADED: screenshot @ 2023-11-04 13:50:49
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-04_13-50-49_screenshot.png]]
 #+BEGIN_QUOTE
 Note that the congestion window is
 12⋅MSS when this loss event occurs. The value of ssthresh is then set to 0.5⋅ cwnd =6⋅MSS. Under
 TCP Reno, the congestion window is set to cwnd = 9⋅MSS and then grows linearly. Under TCP Tahoe,
 the congestion window is set to 1 MSS and grows exponentially until it reaches the value of ssthresh ,
 at which point it grows linearly.
 #+END_QUOTE

**** Figure 3.53 Additive-increase, multiplicative-decrease congestion control
	 :PROPERTIES:
	 :NOTER_PAGE: 319
	 :HIGHLIGHT: #s(pdf-highlight 319 ((0.07247259439707673 0.6420323325635103 0.6851400730816077 0.618013856812933)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-04 13:51:12
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-04_13-51-12_screenshot.png]]

**** Macroscopic Description of TCP Throughput
	 :PROPERTIES:
	 :NOTER_PAGE: 320
	 :HIGHLIGHT: #s(pdf-highlight 320 ((0.07610619469026549 0.4590604026845638 0.3787610619469026 0.4590604026845638)))
	 :END:
 #+BEGIN_QUOTE
 When the window size is w bytes and the
 current round-trip time is RTT seconds, then TCP’s transmission rate is roughly w/RTT. TCP then
 probes for additional bandwidth by increasing w by 1 MSS each RTT until a loss event occurs. Denote
 by W the value of w when a loss event occurs. Assuming that RTT and W are approximately constant
 over the duration of the connection, the TCP transmission rate ranges from W/(2 · RTT) to W/RTT.
 Because TCP’s throughput (that is, rate) increases linearly between the two
 extreme values, we have

 average throughput of a connection=0.75⋅WRTT
 #+END_QUOTE

**** Fairness
	 :PROPERTIES:
	 :NOTER_PAGE: 321
	 :HIGHLIGHT: #s(pdf-highlight 321 ((0.08849557522123894 0.8326621923937361 0.3398230088495575 0.8604026845637585)))
	 :END:
 #+BEGIN_QUOTE
 Consider K TCP connections, each with a different end-to-end path, but all passing through a bottleneck
 link with transmission rate R bps.
 #+END_QUOTE

 #+BEGIN_QUOTE
 A congestion-control
 mechanism is said to be fair if the average transmission rate of each connection is approximately R/K;
 #+END_QUOTE

**** Figure 3.55 Throughput realized by TCP connections 1 and 2
	 :PROPERTIES:
	 :NOTER_PAGE: 323
	 :HIGHLIGHT: #s(pdf-highlight 323 ((0.0831858407079646 0.647427293064877 0.6271386430678466 0.6608501118568233)))
	 :END:

 #+DOWNLOADED: screenshot @ 2023-11-04 14:39:50
 [[file:images/Computer_Networking._A_Top_Down_Approach,_7th/2023-11-04_14-39-50_screenshot.png]]

**** Fairness is impossible
	 :PROPERTIES:
	 :NOTER_PAGE: 323
	 :HIGHLIGHT: #s(pdf-highlight 323 ((0.2908554572271386 0.8035794183445191 0.368141592920354 0.8232662192393736)))
	 :END:
 #+BEGIN_QUOTE
 we assumed that only TCP connections traverse the bottleneck link, that the
 connections have the same RTT value,
 #+END_QUOTE

 #+BEGIN_QUOTE
 In practice, it has been shown that when multiple
 connections share a common bottleneck, those sessions with a smaller RTT are able to grab the
 available bandwidth at that link more quickly as it becomes free (that is, open their congestion windows
 faster) and thus will enjoy higher throughput than those connections with larger RTTs
 #+END_QUOTE
**** 
	 :PROPERTIES:
	 :NOTER_PAGE: 323
	 :HIGHLIGHT: #s(pdf-highlight 323 ((0.22064896755162242 0.851006711409396 0.2831858407079646 0.8514541387024609)))
	 :END:
**** Fairness and UDP
	 :PROPERTIES:
	 :NOTER_PAGE: 324
	 :HIGHLIGHT: #s(pdf-highlight 324 ((0.08200589970501475 0.10022371364653244 0.23539823008849559 0.10425055928411633)))
	 :END:
 #+BEGIN_QUOTE
 applications running over UDP are not being fair—they do not cooperate with the other
 connections nor adjust their transmission rates appropriately. Because TCP congestion control will
 decrease its transmission rate in the face of increasing congestion (loss), while UDP sources need not,
 it is possible for UDP sources to crowd out TCP traffic.
 #+END_QUOTE
**** Fairness and Parallel TCP Connections
	 :PROPERTIES:
	 :NOTER_PAGE: 324
	 :HIGHLIGHT: #s(pdf-highlight 324 ((0.08023598820058997 0.46935123042505594 0.3870206489675516 0.4742729306487696)))
	 :END:
 #+BEGIN_QUOTE
 there is nothing to stop a TCP-based application from using multiple parallel
 connections.
 #+END_QUOTE

 #+BEGIN_QUOTE
 If a new application comes
 along and also uses one TCP connection, then each application gets approximately the same
 transmission rate of R/10. But if this new application instead uses 11 parallel TCP connections, then the
 new application gets an unfair allocation of more than R/2.
 #+END_QUOTE
**** Limitation of transport-layer protocols
	 :PROPERTIES:
	 :NOTER_PAGE: 327
	 :HIGHLIGHT: #s(pdf-highlight 327 ((0.8530973451327434 0.31364653243847873 0.2407079646017699 0.39418344519015663)))
	 :END:
 #+BEGIN_QUOTE
 If the
 network-layer protocol cannot provide delay or bandwidth guarantees to transport-layer segments, then
 the transport-layer protocol cannot provide delay or bandwidth guarantees for the messages sent
 between processes.
 #+END_QUOTE
 #+begin_comment
** Chapter 4 The Network Layer: Data Plane
   :PROPERTIES:
   :NOTER_PAGE: 348
   :END:
*** 4.1 Overview of Network Layer
    :PROPERTIES:
    :NOTER_PAGE: 350
    :END:
*** 4.2 What’s Inside a Router?
    :PROPERTIES:
    :NOTER_PAGE: 358
    :END:
*** 4.3 The Internet Protocol (IP): IPv4, Addressing, IPv6, and More
    :PROPERTIES:
    :NOTER_PAGE: 376
    :END:
*** 4.4 Generalized Forwarding and SDN
    :PROPERTIES:
    :NOTER_PAGE: 402
    :END:
** Chapter 5 The Network Layer: Control Plane
   :PROPERTIES:
   :NOTER_PAGE: 422
   :END:
*** 5.1 Introduction
    :PROPERTIES:
    :NOTER_PAGE: 423
    :END:
*** 5.2 Routing Algorithms
    :PROPERTIES:
    :NOTER_PAGE: 426
    :END:
*** 5.3 Intra-AS Routing in the Internet: OSPF
    :PROPERTIES:
    :NOTER_PAGE: 442
    :END:
*** 5.4 Routing Among the ISPs: BGP
    :PROPERTIES:
    :NOTER_PAGE: 446
    :END:
*** 5.5 The SDN Control Plane
    :PROPERTIES:
    :NOTER_PAGE: 459
    :END:
*** 5.6 ICMP: The Internet Control Message Protocol
    :PROPERTIES:
    :NOTER_PAGE: 472
    :END:
*** 5.7 Network Management and SNMP
    :PROPERTIES:
    :NOTER_PAGE: 475
    :END:
** Chapter 6 The Link Layer and LANs
   :PROPERTIES:
   :NOTER_PAGE: 493
   :END:
*** 6.1 Introduction to the Link Layer
    :PROPERTIES:
    :NOTER_PAGE: 495
    :END:
*** 6.2 Error-Detection and -Correction Techniques
    :PROPERTIES:
    :NOTER_PAGE: 500
    :END:
*** 6.3 Multiple Access Links and Protocols
    :PROPERTIES:
    :NOTER_PAGE: 507
    :END:
*** 6.4 Switched Local Area Networks
    :PROPERTIES:
    :NOTER_PAGE: 524
    :END:
*** 6.5 Link Virtualization: A Network as a Link Layer
    :PROPERTIES:
    :NOTER_PAGE: 548
    :END:
*** 6.6 Data Center Networking
    :PROPERTIES:
    :NOTER_PAGE: 552
    :END:
*** 6.7 Retrospective: A Day in the Life of a Web Page Request
    :PROPERTIES:
    :NOTER_PAGE: 558
    :END:
** Chapter 7 Wireless and Mobile Networks
   :PROPERTIES:
   :NOTER_PAGE: 577
   :END:
*** 7.1 Introduction
    :PROPERTIES:
    :NOTER_PAGE: 579
    :END:
*** 7.2 Wireless Links and Network Characteristics
    :PROPERTIES:
    :NOTER_PAGE: 584
    :END:
*** 7.3 WiFi: 802.11 Wireless LANs
    :PROPERTIES:
    :NOTER_PAGE: 591
    :END:
*** 7.4 Cellular Internet Access
    :PROPERTIES:
    :NOTER_PAGE: 612
    :END:
*** 7.5 Mobility Management: Principles
    :PROPERTIES:
    :NOTER_PAGE: 622
    :END:
*** 7.6 Mobile IP
    :PROPERTIES:
    :NOTER_PAGE: 632
    :END:
*** 7.7 Managing Mobility in Cellular Networks
    :PROPERTIES:
    :NOTER_PAGE: 637
    :END:
*** 7.8 Wireless and Mobility: Impact on ­Higher-Layer Protocols
    :PROPERTIES:
    :NOTER_PAGE: 644
    :END:
** Chapter 8 Security in Computer Networks
   :PROPERTIES:
   :NOTER_PAGE: 655
   :END:
*** 8.1 What Is Network Security?
    :PROPERTIES:
    :NOTER_PAGE: 657
    :END:
*** 8.2 Principles of Cryptography
    :PROPERTIES:
    :NOTER_PAGE: 660
    :END:
*** 8.3 Message Integrity and Digital Signatures
    :PROPERTIES:
    :NOTER_PAGE: 674
    :END:
*** 8.4 End-Point Authentication
    :PROPERTIES:
    :NOTER_PAGE: 686
    :END:
*** 8.5 Securing E-Mail
    :PROPERTIES:
    :NOTER_PAGE: 692
    :END:
*** 8.6 Securing TCP Connections: SSL
    :PROPERTIES:
    :NOTER_PAGE: 698
    :END:
*** 8.7 Network-Layer Security: IPsec and Virtual Private Networks
    :PROPERTIES:
    :NOTER_PAGE: 705
    :END:
*** 8.8 Securing Wireless LANs
    :PROPERTIES:
    :NOTER_PAGE: 714
    :END:
*** 8.9 Operational Security: Firewalls and Intrusion Detection Systems
    :PROPERTIES:
    :NOTER_PAGE: 720
    :END:
** Chapter 9 Multimedia Networking
   :PROPERTIES:
   :NOTER_PAGE: 747
   :END:
 #+end_comment
   
